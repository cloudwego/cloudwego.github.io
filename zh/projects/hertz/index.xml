<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CloudWeGo – Hertz</title><link>https://www.cloudwego.io/zh/projects/hertz/</link><description>Recent content in Hertz on CloudWeGo</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 30 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.cloudwego.io/zh/projects/hertz/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Hertz Release</title><link>https://www.cloudwego.io/zh/blog/releases/hertz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/releases/hertz/</guid><description/></item><item><title>Blog: Hertz v0.9.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2024/05/30/hertz-v0.9.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2024/05/30/hertz-v0.9.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz v0.9.0 版本中主要支持常规迭代与优化。&lt;/p>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ol>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1101">#1101&lt;/a>] 增加一个方法能够放逐掉当前的 RequestContext（请求结束不入池）&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1056">#1056&lt;/a>] 为参数绑定提供更多的默认类型支持&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1057">#1057&lt;/a>] 当请求缺少Host短路时或者非法path时设置全局中间件&lt;/li>
&lt;/ol>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ol>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/921">#921&lt;/a>] 对路由进行严格排序，防止生成代码出现大量的 diff&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1037">#1037&lt;/a>] 在 trace 中过滤 shortConnErr 错误&lt;/li>
&lt;/ol>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ol>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1102">#1102&lt;/a>] 修复当使用 ResponseHeader.Set/Add 设置 Trailer 时，有可能会 panic 的问题&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1107">#1107&lt;/a>] 修复路由排序的失效问题&lt;/li>
&lt;/ol>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ol>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/1064">#1064&lt;/a>] 重构 client query 对于 enum 传递的配置形式&lt;/li>
&lt;/ol></description></item><item><title>Blog: Hertz v0.8.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2024/01/12/hertz-v0.8.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2024/01/12/hertz-v0.8.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz v0.8.0 版本中，除了常规迭代优化之外，我们还带来了一个重要 feature。&lt;/p>
&lt;h2 id="partitioned-cookies">Partitioned cookies&lt;/h2>
&lt;p>在 Hertz v0.8.0 版本中，我们支持了 partitioned cookies 特性。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/1041">https://github.com/cloudwego/hertz/pull/1041&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>三方 Cookie 为 Web 提供了跨站点跟踪的能力，它的存在为 Web 用户的隐私和安全都带来了巨大威胁。Chrome 从 2024 年第一季度开始对 1% 的用户禁用第三方 Cookie，从 2024 年第三季度开始逐步将禁用范围扩大到 100%。
Partitioned Cookies Cookies Having Independent Partitioned State (CHIPS) 作为三方Cookie的替代方案，提供了跨站（cross-site）请求携带三方 Cookie 的能力。&lt;/p>
&lt;h4 id="通过-set-cookie-header-设置-partitioned-cookie">通过 Set-Cookie Header 设置 Partitioned Cookie&lt;/h4>
&lt;pre tabindex="0">&lt;code>Set-Cookie header:
Set-Cookie: __Host-name=value; Secure; Path=/; SameSite=None; Partitioned;
&lt;/code>&lt;/pre>&lt;h3 id="how-to">How to&lt;/h3>
&lt;h4 id="升级-hertz-版本">升级 Hertz 版本&lt;/h4>
&lt;p>Hertz 在 v0.8.0 添加了对 Partitioned Cookies 的支持，你需要升级到&amp;gt;=v0.8.0来使用 Partitioned Cookie。&lt;/p>
&lt;h4 id="如何使用-partitioned-cookies">如何使用 Partitioned Cookies&lt;/h4>
&lt;p>目前 Hertz 支持 Partitioned Cookies，但还不支持通过 SetCookie 传入是否为 Partitioned，我们将在下个小版本增加此功能。在此之前，你可以参考下面的代码示例来使用 Partitioned Cookies。&lt;/p>
&lt;pre tabindex="0">&lt;code>func SetPartitionedCookie(c *app.RequestContext, name, value string, maxAge int, path, domain string, sameSite protocol.CookieSameSite, secure, httpOnly bool) {
if path == &amp;#34;&amp;#34; {
path = &amp;#34;/&amp;#34;
}
cookie := protocol.AcquireCookie()
defer protocol.ReleaseCookie(cookie)
cookie.SetKey(name)
cookie.SetValue(url.QueryEscape(value))
cookie.SetMaxAge(maxAge)
// 如果 name 前缀为 __Host，则 Path 必须为/
cookie.SetPath(path)
cookie.SetDomain(domain)
// Secure 必须为 true。
cookie.SetSecure(secure)
cookie.SetHTTPOnly(httpOnly)
cookie.SetSameSite(sameSite)
cookie.SetPartitioned(true)
c.Response.Header.SetCookie(cookie)
}
func main() {
h := server.Default()
h.GET(&amp;#34;/partitioned&amp;#34;, func(ctx context.Context, c *app.RequestContext) {
SetPartitionedCookie(c, &amp;#34;user&amp;#34;, &amp;#34;hertz&amp;#34;, 1, &amp;#34;/&amp;#34;, &amp;#34;localhost&amp;#34;, protocol.CookieSameSiteNoneMode, true, true)
c.JSON(consts.StatusOK, utils.H{&amp;#34;partitioned&amp;#34;: &amp;#34;yes&amp;#34;})
})
h.Spin()
}
&lt;/code>&lt;/pre>&lt;p>验证 Set-Cookie Header&lt;/p>
&lt;pre tabindex="0">&lt;code>curl -v http://localhost:8888/partitioned
* Trying [::1]:8888...
* Connected to localhost (::1) port 8888
&amp;gt; GET /partitioned HTTP/1.1
&amp;gt; Host: localhost:8888
&amp;gt; User-Agent: curl/8.4.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: hertz
&amp;lt; Date: Fri, 12 Jan 2024 07:01:02 GMT
&amp;lt; Content-Type: application/json; charset=utf-8
&amp;lt; Content-Length: 21
&amp;lt; Set-Cookie: user=hertz; max-age=1; domain=localhost; path=/; HttpOnly; secure; SameSite=None; Partitioned
&amp;lt;
* Connection #0 to host localhost left intact
{&amp;#34;partitioned&amp;#34;:&amp;#34;yes&amp;#34;}%
&lt;/code>&lt;/pre></description></item><item><title>Blog: Hertz v0.7.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/09/26/hertz-v0.7.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/09/26/hertz-v0.7.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz v0.7.0 版本中，除了常规迭代优化之外，我们还带来了一个重要 feature。&lt;/p>
&lt;h2 id="参数绑定重构">参数绑定重构&lt;/h2>
&lt;p>在 Hertz v0.7.0 版本中，我们重构了 hertz 参数绑定&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/541">https://github.com/cloudwego/hertz/pull/541&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="重构说明">重构说明&lt;/h3>
&lt;p>在 Hertz v0.7.0 版本中，我们重构了参数绑定能力，将参数绑定能力收敛到框架本身，以更好地支持用户的需求。本次重构主要有以下特点：&lt;/p>
&lt;ul>
&lt;li>功能一致：
&lt;ul>
&lt;li>Binder：重构后在 Hertz 内部实现了一个默认的 Binder，其功能与重构前完全对齐，并将重构前的绑定能力以拓展的形式实现在 hertz-contrib 下&lt;/li>
&lt;li>Validator： 仍使用 go-tagexpr 作为默认实现，保证功能一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>配置收敛：
&lt;ul>
&lt;li>重构前：参数绑定的行为大多通过全局参数的形式进行配置，可能导致多个组件出现配置冲突&lt;/li>
&lt;li>重构后：以 BindConfig 和 ValidateConfig 的结构通过 &amp;lsquo;WithOption&amp;rsquo; 的形式注入到 Hertz Engine 中，既能统一配置形式，又能避免配置冲突的问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>可自定义 Binder 和 Validator：
&lt;ul>
&lt;li>自定义 Binder：可使用 &amp;ldquo;WithCustomBinder&amp;rdquo; 来注入自定义的 Binder，目前已有拓展 hertz-contrib/binding/go_tagexpr&lt;/li>
&lt;li>自定义 Validator：可使用 &amp;ldquo;WithCustomValidator&amp;rdquo; 来注入自定义的 Validator，目前已经将 go-playground/validator 进行了拓展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>性能提升：重构后绑定性能较之前有提升，详见后文压测数据&lt;/li>
&lt;/ul>
&lt;h3 id="使用方法">使用方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">package&lt;/span> &lt;span style="color:#000">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">import&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/hertz/pkg/app/server/binding&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4e9a06">&amp;#34;github.com/cloudwego/hertz/pkg/app/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">bindConfig&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">binding&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewBindConfig&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">bindConfig&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">LooseZeroMode&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">h&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">New&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">server&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WithBindConfig&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">bindConfig&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">h&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Spin&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="压测数据">压测数据&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz-benchmark/tree/main/binding">https://github.com/cloudwego/hertz-benchmark/tree/main/binding&lt;/a>&lt;/p>
&lt;p>完整的 Release Note 可以参考：&lt;/p>
&lt;ul>
&lt;li>Hertz: &lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.7.0">https://github.com/cloudwego/hertz/releases/tag/v0.7.0&lt;/a>&lt;/li>
&lt;li>Hz(脚手架): &lt;a href="https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.7.0">https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.7.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz 支持 QUIC &amp; HTTP/3</title><link>https://www.cloudwego.io/zh/blog/2023/08/02/hertz-%E6%94%AF%E6%8C%81-quic-http/3/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/08/02/hertz-%E6%94%AF%E6%8C%81-quic-http/3/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>根据 Hertz 的分层设计原则将 QUIC 和 HTTP3 的实现集成到框架中来，对外提供灵活的多协议支持，对内保持足够灵活的扩展性和清晰的架构。
要从头实现一个完整的 QUIC 协议涉及到的工作量比较大且投入产出比相对较低，目前采取更合理的方式：首先定义标准网络传输层接口，之后将开源社区主流的一个或多个成熟的
QUIC 协议实现经过简单的适配和封装通过模块化的方式接入到 Hertz 中来，同时也保留未来独立实现 QUIC 协议的空间。类似目前的网络传输层架构。HTTP/3
同理。
明确了实现路径之后，本文档讨论的主题也就基本上清晰了，主要为：&lt;/p>
&lt;ol>
&lt;li>网络传输层现状和 QUIC 设计层面统一：明确加入 QUIC 的网络传输层接口形态&lt;/li>
&lt;li>协议层扩展 HTTP/3：在明确网络传输层形态之后，基于网络传输层接口实现 HTTP/3&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/docs/hertz.png" alt="HERTZ">&lt;/p>
&lt;h2 id="设计">设计&lt;/h2>
&lt;h3 id="网络传输层">网络传输层&lt;/h3>
&lt;h4 id="现状">现状&lt;/h4>
&lt;p>当前的网络传输层设计主要还是基于 TCP 协议，基本语义为：当连接建立完成（包括 TLS）后为上层提供一个处理协议的回调函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// Callback when data is ready on the connection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Serve&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">conn&lt;/span> &lt;span style="color:#000">Conn&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当前网络传输层提供的标准网络库和 Netpoll 都是在这套接口下面展开的；因此协议层只需要依赖这个接口进行实现，而无需关心网络传输层具体正在提供的实现是什么。
在 TCP 协议提供的框架和语义下面，这套接口是完全够用的，目前 Hertz 基于此接口构建的 HTTP/1.1、HTTP/2 足以证明这一点。&lt;/p>
&lt;h5 id="详细描述">详细描述&lt;/h5>
&lt;p>Conn 的定义为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Conn&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Conn&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Reader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Writer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// SetReadTimeout should work for every Read process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">SetReadTimeout&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">t&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Duration&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主体由 Reader（提供从连接上读数据的能力）/Writer（提供往连接上写数据的能力）构成。
同时也是当前 Hertz 网络传输层高性能库实现的承载，具体定义为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Reader&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Peek returns the next n bytes without advancing the reader.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Peek&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">([]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Skip discards the next n bytes.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Skip&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Release the memory space occupied by all read slices. This method needs to be executed actively to&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// recycle the memory after confirming that the previously read data is no longer in use.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// After invoking Release, the slices obtained by the method such as Peek will&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// become an invalid address and cannot be used anymore.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Release&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Len returns the total length of the readable data in the reader.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Len&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// ReadByte is used to read one byte with advancing the read pointer.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ReadByte&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// ReadBinary is used to read next n byte with copy, and the read pointer will be advanced.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ReadBinary&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Writer&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Malloc will provide a n bytes buffer to send data.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Malloc&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// WriteBinary will use the user buffer to flush.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// NOTE: Before flush successfully, the buffer b should be valid.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">WriteBinary&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">b&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Flush will send data to the peer end.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Flush&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="引入-quic">引入 QUIC&lt;/h4>
&lt;p>UDP + QUIC 大致可以对应到 TCP + TLS（严格的层级关系可以参考下图），按照当前的分层结构，同属于 Hertz 的网络传输层。不过 QUIC
的编程模型天然基于流（Stream）来进行的，而当前基于 TCP 的网络传输层提供的 Reader /Writer 本质上是基于字节流的编程模型。虽然
HTTP/2 非常类似地拥有流（Stream）的概念，但实际上是在 TCP 的字节流之上（应用协议层中）进行的封装，并非如 QUIC
这样原生实现到了传输协议内部。我们无法要求 TCP 直接内置流（Stream）的实现（这可能也是 HTTP/2 的愿望），换句话说，要想把 HTTP/2
和 HTTP/3 中流的概念在当下 Hertz 的某一层中统一起来，逻辑上其实是办不到的（虽然它们本质上是那么的相似）。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/docs/quic_http3.png" alt="quic &amp;amp; http3">&lt;/p>
&lt;p>明确了上述问题之后，引入 QUIC 后的网络库形态其实也就比较清晰了：基于 TCP 的网络抽象接口仍然保持原样，新增一套基于
QUIC（UDP）的网络传输层抽象，协议层对应提供一个基于 QUIC（UDP）网络抽象的处理接口。关键点在于，不强制将 QUIC（UDP）融合至当前基于
TCP 的网络/协议层抽象当中来。&lt;/p>
&lt;h5 id="接口设计">接口设计&lt;/h5>
&lt;p>与当前 TCP 的抽象接口类似，QUIC 和 HTTP/3 的分界其实就是：&lt;/p>
&lt;ol>
&lt;li>网络传输层语义覆盖 QUIC 协议的连接准备、连接建立过程；请求对应的流完成准备之后就达到网络传输层的边界&lt;/li>
&lt;li>协议层关注从 QUIC 连接上打开的流（Stream）开始，通过这个打开的流完成请求的解析，handler 的处理，到将相应通过这条流写回对端（Server 视角，Client 同理，对调即可）&lt;/li>
&lt;/ol>
&lt;p>网络传输层和协议层拆分的优势非常明显，目前的 Hertz 支持 ET/LT 触发方式、标准网络库和 Netpoll 相互补充，丰富应用场景等都是很好的例子。&lt;/p>
&lt;h5 id="方案-a">方案 A&lt;/h5>
&lt;p>基于上述分层思想，一个和网络传输层 Serve 相对应的 QUIC 抽象其实就出具雏形了，命名为 OnStream，语义和 Serve 基本一致*
：当流完成准备。具体需要提供的实现就是上层协议（这里是 HTTP/3）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ServeStream&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">stream&lt;/span> &lt;span style="color:#000">Stream&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>*注：ServeStream 语义和 Serve 一致具体指 HTTP/1 的 Serve 对应的其实就是“下一个请求的数据已经准备好”；通过实现该接口就可以完成协议处理。
如果进一步深入，其实和当前 Hertz HTTP/2 的实现其实并不完全对应，究其原因在于：&lt;/p>
&lt;ol>
&lt;li>HTTP/2
的流实现在协议层上，本质上其实只是对引入的更小传输单元帧（Frame）的逻辑承载；&lt;/li>
&lt;li>理想形态应该是将 HTTP/2
的实现进行拆分：流（Stream）准备逻辑下层到网络传输层 &amp;amp; 基于流（Stream）的协议处理逻辑保留在协议层。&lt;/li>
&lt;/ol>
&lt;h6 id="详细设计">详细设计&lt;/h6>
&lt;p>暂略&lt;/p>
&lt;h6 id="优点">优点&lt;/h6>
&lt;p>方案 A 最大的特点是理想化的将应用协议和网络协议进行分离。
由于各种历史原因的叠加，TCP、HTTP/1、Websocket、HTTP/2、QUIC、HTTP/3 各自的架构设计存在很多重叠和职责界定不清晰的地方，且当下的很多实现可能还并未形成标准，通过合理的解构，能够帮助
Hertz 在面对未来可能的协议变迁、实现变迁的过程中仍然能够聚焦在 HTTP 本身这个核心问题之上，最终达成“泛 HTTP 框架”的终极目标。&lt;/p>
&lt;h6 id="缺点">缺点&lt;/h6>
&lt;p>方案 A 的缺点其实就是伴随清晰的边界产生的，这也是协议设计和发展中的妥协和不彻底带来的一个现实问题。
其中，基于流（Stream）的协议层能很好的处理一个流（Stream）上的消息交互，但是同时也是由于对于协议层来说，仅仅显示暴露了流（Stream）这样一个请求级别的接口，但类似
HTTP/2，HTTP/3 这样基于流（Stream）的应用层协议，一个核心特点在于连接本身的多路复用，换句话说，底层连接和流的对应关系往往是 1:N 的。因此，如果是在协议处理过程中存在对承载流（Stream）的连接本身的控制需求（应该难以避免），就会比较难办（实现上没问题），概念上会和方案 A 的分层抽象存在相抵的地方。
极致的理想态可能并不太适用于当下的真实环境。&lt;/p>
&lt;h5 id="方案-b">方案 B&lt;/h5>
&lt;p>平衡理想形态和事实现状，容易想到的一种解决方案：额外抽象一个连接层出来，这个连接能够拥有操作流（Stream）的语义。网络传输层和协议层的边界从流（Stream）移动到这个连接上面来：&lt;/p>
&lt;ol>
&lt;li>网络传输层负责这个连接的准备工作，当连接建立完成后直接将连接交给协议层&lt;/li>
&lt;li>协议层直接操作建连完成后的链接，不过和 Hertz
当前的网络传输层连接抽象不同，这个连接不具备直接（理论上）读/写数据的接口和能力，涉及到数据交互的操作需要通过连接提供的流（Stream）相关操作进行，比如要想读取数据，需要通过连接接口开启一个双/单向的流，之后的数据交换操作通过这个开启的流来完成&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ServeStream&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">streamConn&lt;/span> &lt;span style="color:#000">StreamConn&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="详细设计-1">详细设计&lt;/h6>
&lt;p>明确新增接口的形态之后，StreamConn 具体能够支持的语义就比较清晰了，具体来说，分为两部分：&lt;/p>
&lt;ul>
&lt;li>支持连接级别控制能力&lt;/li>
&lt;li>支持流（Stream）相关控制能力&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// StreamConn is interface for stream-based connection abstraction.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">StreamConn&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">GetRawConnection&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span>&lt;span style="color:#000;font-weight:bold">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// HandshakeComplete blocks until the handshake completes (or fails).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">HandshakeComplete&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// CloseWithError closes the connection with an error.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// The error string will be sent to the peer.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">CloseWithError&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000">ApplicationError&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">errMsg&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// LocalAddr returns the local address.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">LocalAddr&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Addr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// RemoteAddr returns the address of the peer.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">RemoteAddr&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">net&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Addr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// The context is cancelled when the connection is closed.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Streamer is the interface for stream operations.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Streamer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Streamer&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// AcceptStream returns the next stream opened by the peer, blocking until one is available.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, the error satisfies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// the net.Error interface, and Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">AcceptStream&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Stream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// AcceptUniStream returns the next unidirectional stream opened by the peer, blocking until one is available.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, the error satisfies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// the net.Error interface, and Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">AcceptUniStream&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ReceiveStream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// OpenStream opens a new bidirectional QUIC stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// There is no signaling to the peer about new streams:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// The peer can only accept the stream after data has been sent on the stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the error is non-nil, it satisfies the net.Error interface.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// When reaching the peer&amp;#39;s stream limit, err.Temporary() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">OpenStream&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Stream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// OpenStreamSync opens a new bidirectional QUIC stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// It blocks until a new stream can be opened.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the error is non-nil, it satisfies the net.Error interface.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">OpenStreamSync&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">Stream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// OpenUniStream opens a new outgoing unidirectional QUIC stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the error is non-nil, it satisfies the net.Error interface.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// When reaching the peer&amp;#39;s stream limit, Temporary() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">OpenUniStream&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">SendStream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// OpenUniStreamSync opens a new outgoing unidirectional QUIC stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// It blocks until a new stream can be opened.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the error is non-nil, it satisfies the net.Error interface.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">OpenUniStreamSync&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">SendStream&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Stream&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ReceiveStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">SendStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ReceiveStream&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">StreamID&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Reader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// CancelRead aborts receiving on this stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// It will ask the peer to stop transmitting stream data.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Read will unblock immediately, and future Read calls will fail.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// When called multiple times or after reading the io.EOF it is a no-op.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">CancelRead&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000">ApplicationError&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// SetReadDeadline sets the deadline for future Read calls and&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// any currently-blocked Read call.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// A zero value for t means Read will not time out.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">SetReadDeadline&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">t&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">SendStream&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">StreamID&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Writer writes data to the stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Write can be made to time out and return a net.Error with Timeout() == true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// after a fixed time limit; see SetDeadline and SetWriteDeadline.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the stream was canceled by the peer, the error implements the StreamError&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// interface, and Canceled() == true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// If the connection was closed due to a timeout, the error satisfies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// the net.Error interface, and Timeout() will be true.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Writer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// CancelWrite aborts sending on this stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Data already written, but not yet delivered to the peer is not guaranteed to be delivered reliably.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Write will unblock immediately, and future calls to Write will fail.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// When called multiple times or after closing the stream it is a no-op.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">CancelWrite&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000">ApplicationError&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Closer closes the write-direction of the stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Future calls to Write are not permitted after calling Close.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// It must not be called concurrently with Write.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// It must not be called after calling CancelWrite.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Closer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// The Context is canceled as soon as the write-side of the stream is closed.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// This happens when Close() or CancelWrite() is called, or when the peer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// cancels the read-side of their stream.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// SetWriteDeadline sets the deadline for future Write calls&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// and any currently-blocked Write call.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Even if write times out, it may return n &amp;gt; 0, indicating that&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// some data was successfully written.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// A zero value for t means Write will not time out.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">SetWriteDeadline&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">t&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Time&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ApplicationError&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ErrCode&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">uint64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Stringer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="优点-1">优点&lt;/h6>
&lt;p>相较于方案 A，本方案最大的优势在于，能够在语义层面很好的自洽：协议层与网络传输层的职责节点清晰明确，无需为一些历史问题妥协设计语义，同时当下主流的开源实现（HTTP/2
及 HTTP/3 over QUIC）都能够比较容易得融合到这个架构中来。
对协议层直接暴露连接的接口，给协议层提供了极大的自由度和对连接的控制力，是一个更加符合实际的抽象方式。&lt;/p>
&lt;h6 id="缺点-1">缺点&lt;/h6>
&lt;p>相比于 Hertz 当前存在的网络传输层抽象（主要是 HTTP/1.1 的实现），新增的这套抽象层级上并不完全对等（不过这个也是 HTTP
协议大版本之间的一个明显的 break change），目前看起来，要想完全在抽象层面填平这个 gap
困难相对较大。不过，新增的“基于流的连接”这个概念应该也不完全是一件坏事，针对拥有相似语义的协议簇具有统一语义的作用，不过也要求类似基于流来实现多路复用的协议最好能够按照抽象进行拆分（目前的 Websocket、HTTP/2
还不是此形态）&lt;/p>
&lt;h5 id="方案选型">方案选型&lt;/h5>
&lt;p>方案 B
在综合考虑架构形态和事实的一些主流实现后方案 B 更加符合 Hertz 的分层演进路线&lt;/p>
&lt;h3 id="协议层">协议层&lt;/h3>
&lt;p>基于网络传输层方案 B 进一步往前走，协议层的实现就相对灵活的多了：针对 StreamConn 提供的接口管理连接，同时负责流（Stream）的开启和关闭即可。
不过，由于引入的 StreamConn 和当前网络传输层的 Conn 接口定义不一致，因此协议层更多需要考虑的是基于 StreamConn 和 Conn
的两套回调如何在协议层以及协议服务器（Protocol Server）注册阶段完成融合。基本的要求是对目前的现状不能有任何影响。&lt;/p>
&lt;h4 id="现状-1">现状&lt;/h4>
&lt;p>通过 Hertz 提供的接口就可以便捷的将实现了 Server 接口的自定义协议服务器（Protocol Server）添加到 Hertz 实例支持的协议 map
中来。详细方式参考这里。本质上其实还是要求扩展 Server 实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">conn&lt;/span> &lt;span style="color:#000">network&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Conn&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个接口，而目前的 HTTP/1.1、HTTP/2 的实现也都是按照这个方式来进行的。&lt;/p>
&lt;h4 id="引入-streamconn">引入 StreamConn&lt;/h4>
&lt;h5 id="接口设计-1">接口设计&lt;/h5>
&lt;p>如网络传输层抽象方案 B 所述，新引入的 StreamConn 本身和当前的 network.Conn 在语义上存在很大的 diff，导致硬融合这两个接口为一个存在一定的困难。在“新增
QUIC &amp;amp; HTTP3 支持不能破坏存量抽象”的基本底线之上，更加合理的方式是显示增加一个独立且平行的基于流的 Server
接口：
StreamServer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">StreamServer&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Serve&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">conn&lt;/span> &lt;span style="color:#000">network&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StreamConn&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Protocol server factory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">StreamServerFactory&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#000">New&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">core&lt;/span> &lt;span style="color:#000">Core&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">server&lt;/span> &lt;span style="color:#000">protocol&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StreamServer&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)}&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// Core is the core interface that promises to be provided for the protocol layer extensions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Core&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// IsRunning Check whether engine is running or not&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">IsRunning&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">bool&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// A RequestContext pool ready for protocol server impl&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">GetCtxPool&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">sync&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Pool&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// Business logic entrance&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// After pre-read works, protocol server may call this method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// to introduce the middlewares and handlers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">ServeHTTP&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// GetTracer for tracing requirement&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">GetTracer&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#000">tracer&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Controller&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照这套新的抽象接口展开，对于存量架构的影响就非常小了，不过需要新增针对新增的网络抽象和协议抽象的映射。
当前网络传输层、协议层间不存在明显耦合：&lt;/p>
&lt;p>网络传输层原生提供：&lt;/p>
&lt;ol>
&lt;li>基于 netpoll 的实现&lt;/li>
&lt;li>基于标准库的实现&lt;/li>
&lt;/ol>
&lt;p>协议层提供：&lt;/p>
&lt;ol>
&lt;li>HTTP/1.1&lt;/li>
&lt;li>HTTP/2&lt;/li>
&lt;/ol>
&lt;p>排除掉 Netpoll 不支持 TLS 这一点来看，其实网络传输层和协议层是能够自由组合，总共 4（2*2）种不同的搭配。
但新引入的 StreamConn（网络传输层） 、StreamServer（协议层）其实和上述实现完全平行，如果网络传输层采用 StreamConn 这套抽象接口，协议层也就只能是对接实现了 StreamServer 的 Server 了（目前的 HTTP/1.1、HTTP/2 都不是，不过 HTTP/2 是条流写回对存在改造/重写适配上 StreamConn &amp;amp; StreamServer 的可能性的）。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>&lt;a href="https://github.com/hertz-contrib/http3">https://github.com/hertz-contrib/http3&lt;/a>&lt;/p></description></item><item><title>Blog: Hertz v0.6.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/03/02/hertz-v0.6.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/03/02/hertz-v0.6.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz 0.6.0 版本中，除了常规迭代优化之外，我们还带来了多个重要 feature。&lt;/p>
&lt;h2 id="支持-http-trailer">支持 HTTP Trailer&lt;/h2>
&lt;p>在 Hertz v0.6.0 版本中，我们支持了 HTTP Trailer 的编码和解析。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz-examples/tree/main/trailer">https://github.com/cloudwego/hertz-examples/tree/main/trailer&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>写 Trailer&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// server 端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">handler&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Good&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// client 端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">req&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Good&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>读 Trailer&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// server 端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">handler&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8f5902;font-style:italic">// client 端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">resp&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="http11-支持-response-writer-劫持">HTTP/1.1 支持 Response Writer 劫持&lt;/h2>
&lt;p>在 Hertz v0.6.0 版本中，我们扩展了 HTTP/1.1 写请求的方式，在原来写请求流程的基础之上，支持用户在业务 handler/中间件中劫持 Response Writer，实现更加灵活的写请求方式。
简单来说，原来所有的“底层写”逻辑统一放到 handler/中间件返回之后，这个带来两个比较明显的局限性：&lt;/p>
&lt;ol>
&lt;li>用户无法控制请求真正 flush 到对端的时机&lt;/li>
&lt;li>针对 chunk 方式增量产生数据 &amp;amp; 实时写到对端的场景，在老的架构之上用法相对复杂，限制相对较多&lt;/li>
&lt;/ol>
&lt;p>基于此我们扩展出一套能够提供自行 flush 请求头和请求体的能力，同时提供了一个支持用户按需发送 chunk 数据的 Writer。详细实现参考：https://github.com/cloudwego/hertz/pull/610&lt;/p>
&lt;h3 id="主要变更">主要变更&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>增加了一个扩展 Writer 的接口定义，实现了这个接口的 Writer 都可以用作劫持 Response Writer：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ExtWriter&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Writer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Flush&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Finalize will be called by framework before the writer is released.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Implementations must guarantee that Finalize is safe for multiple calls.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Finalize&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>提供了一个实现了上述接口的 Chunk Writer（有类似需求都可以参考这个来实现）：&lt;code>chunkedBodyWrite&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HTTP/1.1 具体写请求的地方针对被劫持了 Writer 的 Response 写操作做了对应的处理（跳过默认写请求逻辑），最后调用&lt;code>ExtWriter&lt;/code>接口的&lt;code>Finalize()&lt;/code>方法完成一次请求写回&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="使用方法">使用方法&lt;/h3>
&lt;p>如上，Hertz 提供了一个默认的&lt;code>ExtWriter&lt;/code>实现满足用户在 handler/中间件中的主动 flush 需求，使用方式也非常简单：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">h&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GET&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/flush/chunk&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8f5902;font-style:italic">// Hijack the writer of response&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">HijackWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">resp&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewChunkedBodyWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">()))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Write&lt;/span>&lt;span style="color:#000;font-weight:bold">([]&lt;/span>&lt;span style="color:#204a87">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Sprintf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;chunk %d: %s&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">strings&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Repeat&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;hi~&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">))))&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// nolint: errcheck&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Flush&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// nolint: errcheck&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Sleep&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">200&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Millisecond&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="脚手架使用优化--最佳实践">脚手架使用优化 &amp;amp; 最佳实践&lt;/h2>
&lt;p>在 hz v0.6.0 版本中，我们对生成代码的组织结构进行一系列的优化，从而可生成更加灵活的代码组织结构&lt;/p>
&lt;h3 id="主要优化">主要优化&lt;/h3>
&lt;ul>
&lt;li>&lt;code>new&lt;/code> 命令支持 &amp;ldquo;router_dir&amp;rdquo; 选项，并配合已有的 &amp;ldquo;handler_dir&amp;rdquo;、&amp;ldquo;model_dir&amp;rdquo;，可完全自定义 IDL 生成产物的路径；并且会将这些自定义选项持久化到 &amp;ldquo;.hz&amp;rdquo; 文件中，可在 &lt;code>update&lt;/code> 时自动读取，减少命令的复杂度&lt;/li>
&lt;li>增加向上搜索 &amp;ldquo;go.mod&amp;rdquo; 文件的能力，从而使得 hertz 在作为一个子项目时可以和其他项目共享同一个 &amp;ldquo;go module&amp;rdquo;&lt;/li>
&lt;li>增加 &amp;ldquo;handler&amp;rdquo; 中引用第三方 IDL 产物的能力，可将 IDL 产物放到第三方仓库单独维护，使其不在项目目录中存放，进一步增强 IDL 管理能力&lt;/li>
&lt;/ul>
&lt;h3 id="最佳实践">最佳实践&lt;/h3>
&lt;p>我们利用 &amp;ldquo;hz v0.6.0&amp;rdquo; 重写了 &amp;ldquo;&lt;a href="https://github.com/cloudwego/biz-demo/pull/26">biz-demo/easy-note&lt;/a>&amp;quot;，主要利用了如下 hz 的特性&lt;/p>
&lt;ul>
&lt;li>利用 &amp;ldquo;hz client&amp;rdquo; 的能力，基于 IDL 生成访问 &amp;ldquo;api server&amp;rdquo; 的 hertz client 调用代码&lt;/li>
&lt;li>利用自定义 &amp;ldquo;router_dir&amp;rdquo;、 &amp;ldquo;handler_dir&amp;rdquo;、&amp;ldquo;model_dir&amp;rdquo; 选项，重新调整 &amp;ldquo;api server&amp;rdquo; 代码的组织结构，去掉 &amp;ldquo;biz&amp;rdquo; 目录的限制&lt;/li>
&lt;li>利用 &amp;ldquo;向上搜索 go.mod&amp;rdquo; 的能力，使得 &amp;ldquo;api server&amp;rdquo; 可以作为 &amp;ldquo;easy-note&amp;rdquo; 的子项目共享同一个 &amp;ldquo;go module&amp;rdquo;&lt;/li>
&lt;li>利用 &amp;ldquo;handler 引用第三方 IDL 产物&amp;rdquo; 的能力并配合 &amp;ldquo;hz model&amp;rdquo; 的能力，使得 IDL 产物单独存到到 &amp;ldquo;easy-note&amp;rdquo; 项目里，而并不存放到 &amp;ldquo;api server&amp;rdquo; 子项目里&lt;/li>
&lt;/ul>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;/p>
&lt;ul>
&lt;li>Hertz: &lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.6.0">https://github.com/cloudwego/hertz/releases/tag/v0.6.0&lt;/a>&lt;/li>
&lt;li>Hz(脚手架): &lt;a href="https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.6.0">https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.6.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: HTTP 框架 Hertz 实践入门：性能测试指南</title><link>https://www.cloudwego.io/zh/blog/2023/02/24/http-%E6%A1%86%E6%9E%B6-hertz-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</link><pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/02/24/http-%E6%A1%86%E6%9E%B6-hertz-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2021 年 9 月 8 日，字节跳动宣布正式开源 &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a>。CloudWeGo 是一套字节跳动内部微服务中间件集合，具备&lt;strong>高性能、强扩展性和稳定性&lt;/strong>的特点，专注于解决微服务通信与治理的难题，满足不同业务在不同场景的诉求。
2022 年 6 月 21 日，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式开源。日前，CloudWeGo 团队正式开源字节跳动最大的 HTTP 框架 Hertz。Hertz 自发布以来，得到了大量用户的关注，累计收获了 3K+ star。有很多用户自己进行了测试，感谢大家对我们的关注和支持。
本文旨在分享开发者在压测 Hertz 时需要了解的场景和技术问题。这些建议有助于用户更好地结合真实 HTTP 场景对 Hertz 进行调优，使之更贴合业务需要、发挥最佳性能。用户也可以参考官方提供的压测项目 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 了解更多细节。&lt;/p>
&lt;h2 id="微服务-http-场景的特点">微服务 HTTP 场景的特点&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 诞生于字节跳动大规模微服务架构实践，面向的场景自然是微服务场景，因此下面会先介绍微服务 HTTP 场景的特点，方便开发者深入理解 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的设计思考。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HTTP 通信模型&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>微服务间的通信通常以 Ping-Pong 模型为主，除了常规的吞吐性能指标外，每次 HTTP 的&lt;strong>平均时延&lt;/strong>也是开发者需要考虑的点。吞吐达到瓶颈时可以通过增加机器快速解决，但对用户使用体验有显著影响的时延却没有那么容易降低。
在微服务场景下，一次调用往往需要多个微服务协作完成，即使每个节点延迟很低，最终汇聚到链路上的时延也会被放大，因此微服务场景下时延指标是开发者更应该关注的点。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在保证吞吐的前提下，也针对时延做了一定优化。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>长短连接使用&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>由于 TCP 连接首次建立时需要三次握手，如果每个请求都建立新连接，这部分的开销是非常大的。因此对于时延敏感型服务，尽量使用长连接完成请求。在 HTTP 1.1 中，长连接也是默认的选项。
但是没有银弹，维持连接也需要消耗资源，长连接的水平扩展能力也不如短连接。因此，在某些场景下并不适合使用长连接，比如定时拉取配置的场景，
在这个场景下，建连时延对配置影响并不大，且当配置中心负载过高时，希望能够方便的进行水平扩容，这时短连接可能是一个更好的选择。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>包体积大小&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>一个服务的包大小取决于实际的业务场景。HTTP 场景的数据可以放在 query、path、header、body 等地方，不同位置对解析造成的影响也不一样。
HTTP 的 header 是标识符协议，在没有找到特定的标识符之前，框架并不知道 header 还有多少，因此框架需要收到全部的 header 后才能够解析完成，对框架的内存模型不很友好。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也针对 header 解析做了特殊的优化，分配足够的 buffer 空间给 header，减少 header 处理时跨包拷贝的开销。&lt;/p>
&lt;p>同时在字节跳动内部线上服务的统计中，发现大部分包在 1K 以内（但是太小的包没有实际意义，比如固定返回 &amp;ldquo;hello world&amp;rdquo;），同时大包场景上不封顶，各个包大小均有涉及，所以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在最常用的 128k 以内的包的性能（吞吐和时延）进行了重点优化。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>并发数量&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>每个实例的上游可能会有很多个，不会只接受某个实例的请求；而且，HTTP 1 的连接不能够多路复用，每条连接上只能同时处理一个请求。因此 Server 需要接受多个连接同时处理。
不同服务的连接使用率也不同，比如压测服务的连接使用率很高，一个请求完成后马上就会进行下一个请求；有的服务连接使用率很低，虽然是长连接，但是只使用一次。这两者使用的连接模型并不相同，
前者应使用 goroutine per connection 的模型减少上下文的切换，后者应使用协程池减少过多 goroutine 的调度开销。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也同时支持这两种场景，用户可以根据自己的业务场景选择合适的配置。&lt;/p>
&lt;h2 id="针对-http-场景进行压测">针对 HTTP 场景进行压测&lt;/h2>
&lt;h3 id="使用贴近自己的场景">使用贴近自己的场景&lt;/h3>
&lt;p>Github 上的压测项目有很多，网络上也有很多性能测试报告，但是这些项目和测试不一定贴合自己。举个极端一点的例子，在真实场景中你会写一个项目无论 Client 发什么 Server 都只回 &lt;strong>&lt;code>hello world&lt;/code>&lt;/strong> 吗？很遗憾，很多的压测项目就是这么做的。&lt;/p>
&lt;p>在进行压测前，应考虑自己真正的使用场景，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>长短连接的使用&lt;/strong> ：使用长连接还是短连接更符合自己的场景。&lt;/li>
&lt;li>&lt;strong>连接使用率的估算&lt;/strong> ：如果使用长连接，且连接使用率很高（大部分场景），则使用默认配置即可；如果连接使用率很低，可以添加配置：&lt;strong>&lt;code>server.WithIdleTimeout(0)&lt;/code>&lt;/strong>，将 goroutine per connection 的模型修改为协程池模型，并进行对比测试。&lt;/li>
&lt;li>&lt;strong>数据位置及大小的确定&lt;/strong> ：上面提到不同位置（如 query、header、body 等）及大小的数据对框架可能造成影响，如果所有框架的性能都比较一般，可以考虑换一个数据传输位置。&lt;/li>
&lt;li>&lt;strong>并发数的确定&lt;/strong> ：有的服务属于轻业务重框架，这个时候框架的并发可能会很高；有的服务属于重业务轻框架，这个时候框架的并发可能会很低。&lt;/li>
&lt;/ul>
&lt;p>如果只是想看一下框架的性能，可以使用常规的场景：&lt;strong>长连接、较高连接使用率、1k body、100 并发&lt;/strong>等。&lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库默认的压测配置也是如此。
同时 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库也开发给用户 header、body、并发数的配置，用户可以方便的修改这些配置完成贴合自己的压测。&lt;/p>
&lt;h3 id="确定压测对象">确定压测对象&lt;/h3>
&lt;p>衡量一个 RPC 框架的性能需要从两个视角分别去思考：Client 视角与 Server 视角。在大规模的业务架构中，上游 Client 不见得使用的也是下游的框架，而开发者调用的下游服务也同样如此，如果再考虑到 Service Mesh 的情况就更复杂了。&lt;/p>
&lt;p>一些压测项目通常会把 Client 和 Server 进程混部进行压测，然后得出&lt;strong>整个框架&lt;/strong>的性能数据，这其实和线上实际运行情况很可能是不符的。&lt;/p>
&lt;p>如果要压测 Server，应该给 Client 尽可能多的资源，把 Server 压到极限，反之亦然。如果 Client 和 Server 都只给了 4 核 CPU 进行压测，会导致开发者无法判断最终得出来的性能数据是哪个视角下的，更无法给线上服务做实际的参考。&lt;/p>
&lt;h3 id="使用独占-cpu">使用独占 CPU&lt;/h3>
&lt;p>虽然线上应用通常是多个进程共享 CPU，但在压测场景下，Client 与 Server 进程都处于极端繁忙的状况，此时共享 CPU 会导致大量上下文切换，从而使得数据缺乏可参考性，且容易产生前后很大波动。&lt;/p>
&lt;p>所以我们建议是将 Client 与 Server 进程隔离在不同 CPU 或者不同独占机器上进行。如果还想要进一步避免其他进程产生影响，可以再加上 nice -n -20 命令调高压测进程的调度优先级。&lt;/p>
&lt;p>另外如果条件允许，相比云平台虚拟机，使用真实物理机会使得测试结果更加严谨与具备可复现性。&lt;/p>
&lt;h2 id="性能数据参考">性能数据参考&lt;/h2>
&lt;p>在满足上述要求的前提下，我们基于当前最新版本对多个框架进行了压测对比，压测代码在 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库。
在充分压满 Server 的目标下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 P99 延迟在所有压测框架中最低，吞吐也是属于第一梯队，且在持续优化中。&lt;/p>
&lt;ul>
&lt;li>CPU: AMD EPYC 7Y83 64-Core Processor 2.7GHz
&lt;ul>
&lt;li>运行限定 server 4-CPUs，client 16-CPUS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>OS：Debian GNU/Linux 10 (buster)&lt;/li>
&lt;li>Go 1.19&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.3.2">hertz v0.3.2&lt;/a>，&lt;a href="https://github.com/valyala/fasthttp/releases/tag/v1.40.0">fasthttp v1.40.0&lt;/a>，
&lt;a href="https://github.com/gin-gonic/gin/releases/tag/v1.8.1">gin v1.8.1&lt;/a>，&lt;a href="https://github.com/gofiber/fiber/releases/tag/v2.38.1">fiber v2.38.1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz-benchmark/1.png" alt="image">&lt;/p>
&lt;p align="center">四个框架的吞吐和时延比较&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz-benchmark/2.png" alt="image">&lt;/p>
&lt;p align="center">三个框架的吞吐和时延比较&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>作为一个超大规模企业级的微服务 HTTP 框架，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在设计之初就更倾向于解决大规模微服务场景下的各种问题。在推广过程中也遇到了各种各样的服务，踩了各种各样的坑，也是基于以上经验写了本文。
欢迎广大开发者基于本文提供的测试指南，针对自己的实际场景选择合适的工具。更多问题，请在 GitHub 上提 &lt;a href="https://github.com/cloudwego/hertz/issues">Issue&lt;/a> 交流。&lt;/p></description></item><item><title>Blog: Hertz v0.5.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/01/12/hertz-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/01/12/hertz-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz 0.5.0 版本中，除了常规迭代优化之外，我们还带来了多个重要 feature。&lt;/p>
&lt;h2 id="网络层和协议层支持基于流的接口">网络层和协议层支持基于流的接口&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/467">https://github.com/cloudwego/hertz/pull/467&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 Hertz v0.5.0 版本中，我们进一步加强了 Hertz 传输层 &amp;amp; 协议层可扩展能力，支持无缝对接基于流的传输层协议 QUIC，以及在此之上构建的 &lt;a href="https://github.com/cloudwego/hertz/issues/458">HTTP3 协议。&lt;/a>
此外，我们在此基础上还增加和完善了 &amp;ldquo;ALPN&amp;rdquo;(应用层协议协商)、&amp;ldquo;QUIC/TLS parallel monitoring&amp;rdquo;(QUIC/TLS并行监听)、&amp;ldquo;Alt-Svc&amp;rdquo;(备选服务) 等功能。&lt;/p>
&lt;h3 id="主要变更">主要变更&lt;/h3>
&lt;h4 id="传输层">传输层&lt;/h4>
&lt;p>我们在保证兼容性能的基础之上增加了一个针对基于流（stream-based）的网络连接接口抽象&lt;code>StreamConn&lt;/code>，同时调整传输层和协议层的交互逻辑，实现针对连接类型的分发正确的协议层处理（protocol server）。
针对需要同时监听监听 TCP（TLS）以及 UDP(QUIC)的场景我们提供了一个&lt;code>WithAltTransporter&lt;/code>选项，方便将备用 transporter 传递到主 transporter 中，便于实现 QUIC/TLS 并行监听的能力。&lt;/p>
&lt;h4 id="协议层">协议层&lt;/h4>
&lt;p>支持添加基于流的协议层实现（protocol server）&lt;code>StreamServer&lt;/code>，以便于在新增的基于流的传输层扩展之上构建对应处理协议（HTTP/3）。
为了便捷的实现为某个主协议（HTTP/3）配置备选服务元信息，&lt;code>ProtocolSuite&lt;/code>对外暴露&lt;code>SetAltHeader&lt;/code>接口。
同时，我们也为&lt;code>StreamConn&lt;/code>设计了 ALPN 能力，以便于在 QUIC 内提供协议协商的能力。&lt;/p>
&lt;h4 id="通用层">通用层&lt;/h4>
&lt;p>同时我们在通用层中新增了能够与 Golang 标准 Handler 进行转换的辅助函数，以便于快速的将基于 Golang 标准 Handler 实现移植到 Hertz 中来。在之后提供的基于 &lt;a href="https://github.com/lucas-clemente/quic-go">quic-go&lt;/a> 的 &lt;a href="https://github.com/hertz-contrib/http3/pull/1">QUIC &amp;amp; HTTP/3 扩展&lt;/a>中，就用到了这个函数提供的能力。&lt;/p>
&lt;h4 id="feature-状态">Feature 状态&lt;/h4>
&lt;p>Hertz 核心库能力已经发布，具体实现后续将以&lt;a href="https://github.com/hertz-contrib/http3/pull/1">扩展包&lt;/a>的形式发布，欢迎试用~&lt;/p>
&lt;p>更多详细的设计说明可以参考：&lt;a href="https://www.cloudwego.io/zh/blog/2023/08/02/hertz-%E6%94%AF%E6%8C%81-quic-http/3/">Hertz 支持 QUIC &amp;amp; HTTP/3&lt;/a>&lt;/p>
&lt;h2 id="脚手架工具支持生成-hertz-client-代码">脚手架工具支持生成 hertz client 代码&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/471">https://github.com/cloudwego/hertz/pull/471&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在脚手架工具(Hz)的 v0.5.0 的版本，我们支持了基于 IDL 自动生成 hertz client 代码的功能，并实现了类 RPC 调用形式的 HTTP 请求一键调用。
使用方法：&lt;/p>
&lt;blockquote>
&lt;p>具体详见：https://github.com/cloudwego/hertz-examples/tree/main/hz_client&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>定义 IDL&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">namespace&lt;/span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#000">toutiao&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">middleware&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">hzClient&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">QueryReq&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#000">QueryValue&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">query&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;query1&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">Resp&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#000">Resp&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">service&lt;/span> &lt;span style="color:#000">Hertz121&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">Resp&lt;/span> &lt;span style="color:#000">QueryMethod&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">QueryReq&lt;/span> &lt;span style="color:#000">request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">get&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/query&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">handler_path&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">}(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">base_domain&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;http://127.0.0.1:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>生成代码&lt;/li>
&lt;/ol>
&lt;p>可基于上述 IDL，分别生成 server 和 client 端代码：&lt;/p>
&lt;p>server：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">hz&lt;/span> &lt;span style="color:#000">new&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">idl&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">psm&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">thrift&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">handler_by_method&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">template&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">slim&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>client：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#000">hz&lt;/span> &lt;span style="color:#000">client&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">idl&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">psm&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">thrift&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">model_dir&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">hertz_gen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">template&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">slim&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">client_dir&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">hz_client&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>调用 client 代码发起 HTTP 请求，实现 client 端和 server 端的互通&lt;/li>
&lt;/ol>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;/p>
&lt;ul>
&lt;li>Hertz: &lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.5.0">https://github.com/cloudwego/hertz/releases/tag/v0.5.0&lt;/a>&lt;/li>
&lt;li>Hz(脚手架): &lt;a href="https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.5.0">https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.5.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.4.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/10/28/hertz-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/10/28/hertz-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/289">#289&lt;/a>] feat: render 支持 IndentedJSON。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/304">#304&lt;/a>] feat: recovery 中间件支持用户自定义错误输出格式。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/278">#278&lt;/a>] feat: 增加编译 tag 控制实际使用的 json 库。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/239">#239&lt;/a>] feat: 给 client 扩展复杂重试能力。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/265">#265&lt;/a>] feat: 在标准网络库扩展上添加 CloseNoResetBuffer 方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/258">#258&lt;/a>] feat: 支持 &lt;code>errors&lt;/code> 的格式化。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/295">#295&lt;/a>] optimize: 服务端忽略客户端主动断连的写错误。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/322">#322&lt;/a>] optimize: 修改 recovery 中间件的默认日志。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/266">#266&lt;/a>] optimize(hlog): 区分系统日志和默认日志，提供更自由的 logger 定制化能力。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/280">#280&lt;/a>] optimize: 使用标准库时 listen 前添加日志。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/318">#318&lt;/a>] refactor: 添加 SetRetryIf 保持兼容。&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/299">#299&lt;/a>] test: 提高对 &lt;code>hertz/pkg/protocol/header&lt;/code> 的单测覆盖率。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/290">#290&lt;/a>] test: 为 &lt;code>pkg/app/server/option.go&lt;/code> 补充单元测试。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/274">#274&lt;/a>] test: 增加 internal/bytesconv 包测试覆盖率，覆盖率从 1.68% 提高到了 82.35%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/285">#285&lt;/a>] test: 给 &lt;code>pkg/protocol/request.go&lt;/code> 文件单测覆盖率 51.31% 提高到 85.3%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/271">#271&lt;/a>] test: 为 &lt;code>pkg/network&lt;/code> 补充单元测试。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/264">#264&lt;/a>] test: 增加对 &lt;code>hertz/pkg/common/adaptor&lt;/code> 的单测，覆盖率从 76.6% 提高到了 92.3%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/267">#267&lt;/a>] test(pkg/common/config): 增加 pkg/common/config 包测试覆盖率。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/328">#328&lt;/a>] docs: 添加 lark 扩展到 readme.md。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/325">#325&lt;/a>] docs: 更新 README 和 README_cn 的性能数据。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/307">#307&lt;/a>] docs(README): 将 Hertz 扩展添加到 readme 列表中。&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/316">#316&lt;/a>] style: 去掉 license 顶层的空注释。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/272">#272&lt;/a>] chore: 更新 sonic 版本。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/310">#310&lt;/a>] chore: 修改注释信息为行注释避免 buildtag 格式问题的导致 ci 报错。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 助力字节降本增效，大规模企业级 HTTP 框架 Hertz 设计实践</title><link>https://www.cloudwego.io/zh/blog/2022/09/27/%E5%8A%A9%E5%8A%9B%E5%AD%97%E8%8A%82%E9%99%8D%E6%9C%AC%E5%A2%9E%E6%95%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BC%81%E4%B8%9A%E7%BA%A7-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 27 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/27/%E5%8A%A9%E5%8A%9B%E5%AD%97%E8%8A%82%E9%99%8D%E6%9C%AC%E5%A2%9E%E6%95%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BC%81%E4%B8%9A%E7%BA%A7-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="字节跳动内部-go-http-框架的变迁">字节跳动内部 Go HTTP 框架的变迁&lt;/h2>
&lt;p>在正式开始介绍第一部分的内容之前，先展示一组关键词。2020 年初 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 立项，2020 年 10 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 发布&lt;strong>第一个可用版本&lt;/strong> 。
&lt;strong>2022 年 6 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式开源。&lt;/strong> 截至目前，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在字节内部已经支撑&lt;strong>超过 1.4 万个业务服务&lt;/strong> ， &lt;strong>日峰值 QPS 超过 5000 万&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 不仅支持业务服务，同时还会横向支持字节内部的各种基础组件，包括但不限于字节跳动服务网格控制面、公司级别压测平台以及 FaaS，还包括各种业务网关等等。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的高性能和极强的稳定性可以支撑业务复杂多变的场景。在公司内部 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 接替了大量基于 Gin 框架开发的存量服务，大幅度降低了业务资源使用成本以及服务延时，助力公司层面的降本增效。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/1.png" alt="image">&lt;/p>
&lt;p>下面我们可以从 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 出现的背景以及 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的设计目标和思路体会到，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的出现绝不是偶然。&lt;/p>
&lt;h3 id="基于-gin-封装">基于 Gin 封装&lt;/h3>
&lt;p>众所周知，字节内部使用 Golang 比较早，在大约 2014 年左右，公司就已经开始尝试做一些 Golang 业务的转型。2016 年，我们基于已开源的 Golang HTTP 框架 Gin 框架，封装了 Ginex，这是 Ginex 刚开始出现的时期。&lt;/p>
&lt;p>同时，2016 年还是一个开荒的时代，这个时期框架伴随着业务快速野蛮地生长，我们的口号是“大力出奇迹”，把优先解决业务需求作为第一要务。Ginex 的迭代方式是业务侧和框架侧在同一个仓库里面共同维护和迭代。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/2.png" alt="image">&lt;/p>
&lt;h3 id="问题显现">问题显现&lt;/h3>
&lt;p>2017 - 2019 年期间，也就是 Ginex 发布之后，问题逐渐显现。主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>迭代受开源项目限制&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Ginex 是一个基于 Gin 的开源封装，所以它本身在迭代方面是受到一些限制的。一旦有针对公司级的需求开发，以及 Bugfix 等等，我们都需要和开源框架 Gin 做联合开发和维护，这个周期不能完全由我们自己控制。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码混乱膨胀、维护困难&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>由于我们和业务同学共同开发和维护 Ginex 框架，因此我们对于控制整个框架的走向没有完全的自主权，从而导致了整体代码混乱膨胀，到后期我们发现越来越难维护。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无法满足性能敏感业务需求&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>另外，我们能用 Gin 做的性能优化非常少，因为 Gin 的底层是基于 Golang 的一个原生库，所以如果我们要做优化，需要在原生库的基础上做很多改造，这个其实是非常困难的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无法满足不同场景的功能需求&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们内部逐渐出现了一些新的场景，因此会有对 HTTP Client 的需求，支持 Websocket、支持 HTTP/2 以及支持 HTTP/3 等等需求，而在原生的 Ginex 上还是很难扩展的这些功能需求。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/3.png" alt="image">&lt;/p>
&lt;h3 id="魔改开源框架">魔改开源框架&lt;/h3>
&lt;p>逐渐地，某些业务线开始做初步的尝试，他们会对另外的一些开源框架进行魔改。比较典型的例子是有一些业务线尝试基于 Fasthttp 进行魔改，Fasthttp 是一款主打高性能的开源框架，基于它进行魔改可以短期内帮助业务解决问题。
这种魔改现象带来的问题是，框架魔改是一些业务线自发的行为，各个业务线可能会基于自身业务特性进行各自维护，从而导致维护成本上升非常严重。&lt;/p>
&lt;p>到这里我们仿佛陷入了 Ginex 的怪圈。如前段时间爆火的电视剧《开端》一样，我们仿佛是从一辆开往学院南路的 45 路公交车上醒来，发现自己要前往公司进行下一代 Ginex 框架的维护工作。&lt;/p>
&lt;p>大家也可以思考一下，如果是你来应对这样的场景，你会怎么做呢？&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/4.png" alt="image">&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>第一章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>早期基于开源框架封装&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>基于早期开源的 Golang HTTP 框架，实现了 Ginex 的封装。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>随着实践发展，问题逐渐出现&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>框架混乱膨胀，框架的维护越来越困难，业务的新需求无法得到很好地满足。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>为了解决问题出现基于另外的开源框架魔改的萌芽&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们需要思考如何跳出魔改的怪圈，把字节内部的企业级框架做得更好。&lt;/p>
&lt;p>另外，还有一个遗留问题，就是应该如何跳出这个魔改的怪圈呢？这个问题第二章节会为大家进行解答。&lt;/p>
&lt;h2 id="企业级-http-框架的设计考量和落地思路">企业级 HTTP 框架的设计考量和落地思路&lt;/h2>
&lt;h3 id="跳出怪圈">跳出怪圈&lt;/h3>
&lt;p>为了跳出魔改的怪圈，我们决定从以下三个方面开始着手。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自主研发&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>既然 Ginex 是因为基于开源框架 Gin，没法做一些灵活的控制，那我们就改为完全自主研发框架。自主研发框架的代码全链路自主可控，也可以避免引入任何三方不可控因素，这样我们能够对自己的框架有一个比较完备的掌控力。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>质量控制&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>下图列举了一些常规的质量控制手段。我要着重强调的是模糊测试，模糊测试在字节内部是广泛应用于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的稳定性测试中。它的核心点在于 &lt;strong>通过一系列的模拟服务，尝试模拟出线上用户在使用我们的框架时，
实际遇到的一些场景和使用方式&lt;/strong> 。然后通过一些随机的算法，生成尽可能复杂、覆盖各种 Case 的场景，这可以让我们 &lt;strong>检测出一些潜在的问题&lt;/strong> 。这套测试也在 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 早期的质量建设中，帮助我们将一些问题防患于未然。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>严格准入&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>既然 Ginex 的问题是大家都在向里面写入内容，那么我们可以控制入口，建立一套完备的需求开发以及 Review 的闭环，控制迭代的整体流程，从而控制代码准入。同时我们配备统一的需求管理以及严格的发版准入规范，做一个标准的公司级别的框架。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/5.png" alt="image">&lt;/p>
&lt;p>举一个比较形象的例子，如果我们把下一代框架比作一个人——“框架人”，自主研发表示这个“框架人”首先会拥有对自己身体的主导权，他不会受到来自于环境或者他人的影响；
质量控制表示“框架人”能够定期体检，提早发现一些潜在的疾病，将其扼杀于摇篮；严格准入表示“框架人”有科学的饮食摄入和自律的生活习惯。可想而知，如果我们能够做到以上三点，我们的“框架人”就能够拥有一个健康的体魄。&lt;/p>
&lt;h3 id="痛点梳理">痛点梳理&lt;/h3>
&lt;p>明确了应该如何跳出怪圈之后，我们还应该明确知道这个框架要具备哪些功能和特性，也就是首先应该聚焦到框架的核心痛点上。“框架人”不能只有健康的体魄，还应该拥有有趣的思想和灵魂。
一个成熟的框架不仅仅要&lt;strong>应对来自业务侧的需求&lt;/strong> ，如功能需求、性能需求和易用稳定等，还要考虑&lt;strong>框架自身的发展&lt;/strong> ，而这一点恰恰是我们在 Ginex 的迭代过程中忽略的。&lt;/p>
&lt;p>如下图右侧金字塔所示，最上层是&lt;strong>高效支撑&lt;/strong> ，毋庸置疑框架的存在肯定是为了支撑我们的业务需求。中间层是一个&lt;strong>质量保证&lt;/strong>的红线框架，框架需要保证它自身的质量，
只有以高质量完成的框架才能有自信承担字节内部的 5000 万 QPS，以及各种各样的使用场景。金字塔的最底层是&lt;strong>长期、可持续性发展&lt;/strong> ，这也是作为未来想要保持持续迭代的框架最重要的一点。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/6.png" alt="image">&lt;/p>
&lt;h3 id="框架科学发展观">框架科学发展观&lt;/h3>
&lt;p>基于上一部分，我们可以进一步梳理出框架的需求痛点。&lt;strong>痛点&lt;/strong>主要有两个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多样的需求&lt;/strong>：支撑支撑各个业务线及基础设施 （横向扩展性）。&lt;/li>
&lt;li>&lt;strong>灵活的结构&lt;/strong>：贯穿 HTTP 生命周期的掌控力 （纵向模块化）。&lt;/li>
&lt;/ul>
&lt;p>在此基础上进一步抽象出框架的 &lt;strong>科学发展观&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>聚类需求&lt;/strong>：面向通用能力展开设计。&lt;/li>
&lt;li>&lt;strong>跳出局部&lt;/strong>：针对一些复杂问题，在更大范围内寻求最优解。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/7.png" alt="image">&lt;/p>
&lt;p>后续我会针对这个科学发展观进一步阐述 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 究竟是如何实现的。&lt;/p>
&lt;h3 id="小结-1">小结&lt;/h3>
&lt;p>第二章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>跳出怪圈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>引入“框架人”的概念，帮助大家理解框架的自研、质量控制和严格准入。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>痛点梳理&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>为“框架人”注入有趣的灵魂，框架需要应对来自业务侧的多样化需求，还要保证自己的可持续性发展。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>框架科学发展观&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>需求聚类，跳出局部。&lt;/p>
&lt;h2 id="hertz-的核心特点">Hertz 的核心特点&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架是如何实现第二章节中提到的框架痛点和科学发展观的呢？本章节将具体进行介绍。&lt;/p>
&lt;h3 id="分层抽象">分层抽象&lt;/h3>
&lt;p>首先介绍 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的架构设计。下图是一个请求从建立、连接到完成的全过程。&lt;strong>左侧是客户端，右侧是服务端&lt;/strong> ，在我们发起链接建立请求之后，链接建立完成；
之后客户端发起请求到服务端，服务端进行路由处理，然后将路由导向业务逻辑处理；业务逻辑处理完毕后，服务端返回这个请求，完成一次 HTTP 请求的调用。&lt;/p>
&lt;p>那么在这个过程中我们的框架到底做了哪些事情呢？从图中不难发现，首先框架进行了&lt;strong>链接处理&lt;/strong> ，其次是&lt;strong>协议处理&lt;/strong> ，之后基于路由做了逻辑分发，
即&lt;strong>路由处理&lt;/strong> ，最后做了&lt;strong>业务逻辑处理&lt;/strong> 。我们把框架做成一个结构之后会发现，这个结构包含的就是这四部分。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/8.png" alt="image">&lt;/p>
&lt;p>基于这个逻辑，我们可以看一下 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的整体架构图。如下图所示，从下往上看红线框圈住的部分，可以发现这就是上文提到的请求建立的全过程。各层的能力及作用如下：&lt;/p>
&lt;ul>
&lt;li>传输层 Transport：抽象网络接口；&lt;/li>
&lt;li>协议层 Protocol：解析请求，渲染响应编码；&lt;/li>
&lt;li>路由层 Route：基于URL进行逻辑分发；&lt;/li>
&lt;li>应用层 Application：业务直接交互，出现大量 API。&lt;/li>
&lt;/ul>
&lt;p>我们可以看到图中除了中间部分包含的四层，左右两侧各有两列。&lt;strong>右侧是通用层 Common&lt;/strong> ，主要负责&lt;strong>提供通用能力、常用的日志接口、链路追踪以及一些配置处理相关的能力&lt;/strong>等。
&lt;strong>左侧是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的代码生成工具 Hz，又称脚手架工具&lt;/strong> ，它可以帮助我们在内部 &lt;strong>基于 IDL 快速地生成项目骨架&lt;/strong> ，以加速业务迭代。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/9.png" alt="image">&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的分层设计是能够和代码组织结构一一映射的。下图是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 仓库里面的代码组织结构，可以看到根目录下的 cmd 包里面存放着 Hz 工具，
在 pkg 包下存放着上述主要四层以及通用层 Common。因此同学们看到架构设计图之后，可以直接在 Github 学习 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的代码。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/10.png" alt="image">&lt;/p>
&lt;p>总体来说，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的架构设计理念就是 &lt;strong>“简洁有序，保证让所有开发者轻松理解，在开发的过程中持续贯彻”&lt;/strong> 。&lt;/p>
&lt;h3 id="易用可扩展">易用可扩展&lt;/h3>
&lt;p>那么基于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的架构设计，应该如何展开易用性和可扩展性呢？下图是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 架构主要四个层级的抽象。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>应用层提供了一些通用能力，包括&lt;strong>绑定请求、响应渲染、服务发现/注册/负载均衡以及服务治理&lt;/strong>等等。其中，&lt;strong>洋葱模型中间件&lt;/strong>的核心目的是让业务开发同学&lt;strong>基于这个中间件快速地给业务逻辑进行扩展&lt;/strong>，
扩展方式是可以在业务逻辑处理前和处理后分别插桩埋点做相应处理。一些比较有代表性的应用，包括日志打点、前置的安全检测，都是通过洋葱模型中间件进行处理的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>路由层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>路由层也是非常通用的，主要提供&lt;strong>静态路由、参数路由、为路由配置优先级以及路由修复&lt;/strong>的能力，如果我们的路由层没办法满足用户需求，
它还能支撑用户做&lt;strong>自定义路由&lt;/strong>的扩展。但实际应用中这些路由能力完全能够满足绝大多数用户的需求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协议层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 同时提供 &lt;strong>HTTP/1.1&lt;/strong> 和 &lt;strong>HTTP/2&lt;/strong>，&lt;strong>HTTP/3&lt;/strong> 也是我们在建设中的能力，我们还会提供 &lt;strong>Websocket 等 HTTP 相关的多协议支持&lt;/strong> ，以及支持完全由业务决定的&lt;strong>自定义协议层扩展&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传输层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>目前我们已经内置了两个高性能的传输层实现。一个是&lt;strong>基于 CloudWeGo 开源的高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>&lt;/strong> 的传输层扩展，另一个是支持&lt;strong>基于标准库&lt;/strong>的传输层扩展。此外，我们也同样能支持在传输层上进行&lt;strong>自定义传输层协议扩展&lt;/strong> 。&lt;/p>
&lt;p>下图每一层中标红的能力都能够体现出，我们能够在框架的任何一个分层上支撑用户做最大程度的自由定制，这样可以最大程度地满足企业级内部用户和潜在用户的业务需求。
如果同学们想要深入了解 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，可以参考 CloudWeGo 官网的 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/">Hertz&lt;/a> 部分，上述所有内容均有具体描述。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/11.png" alt="image">&lt;/p>
&lt;h3 id="性能探索">性能探索&lt;/h3>
&lt;p>在性能方面，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 又是如何在自主可控的范围内做高性能探索的呢？&lt;/p>
&lt;h4 id="场景描述">场景描述&lt;/h4>
&lt;p>熟悉 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 代码的同学会发现，我们的 &lt;strong>HTTP/1.1&lt;/strong> 协议借鉴了一些 Fasthttp 的优化思路和手段。HTTP/1.1 协议中的 Header 为不定长数据段，往往需要解析到最后一行，才能够确定是否完成解析。
同时，为了减少系统调用次数，提升整体解析效率，涉及 IO 操作时，我们通常引入带 buffer 的 IO 数据结构。如下图所示，它的核心点是最下层的 buffer，buffer 是一个类似于一块完整的内存空间，我们可以将 IO 读到的数据放进这个空间做暂存。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/12.png" alt="image">&lt;/p>
&lt;h4 id="bufioreader-的问题">bufio.Reader 的问题&lt;/h4>
&lt;p>这样做出现的问题是，原生的 bufio.Reader 长度是固定的，请求的 Header 大小超出 buffer 长度后，&lt;code>.Peek()&lt;/code> 方法直接报错 &lt;code>(ErrBufferFul)&lt;/code>，无法完成既定语义功能。&lt;/p>
&lt;h4 id="一些可能的解">一些可能的解&lt;/h4>
&lt;p>对于上述问题，其实有一些可能的解决方法：&lt;/p>
&lt;ul>
&lt;li>直接利用 bufio.Reader 的局限当做 Feature，通过 buffer 大小作为 Header 大小的限制。如果超出这个大小，Header 直接解析报错，这也是 Fasthttp 的做法。
但实际上超出 buffer 长度后报错会导致我们没办法处理这部分请求，从而导致框架 &lt;strong>功能受限&lt;/strong> 。&lt;/li>
&lt;li>header 解析带状态，暂存中间数据，通过在上层堆叠额外复杂度的方式突破 bufio 本身的限制。但是暂存中间态会涉及到一些内存的拷贝，必然会导致 &lt;strong>性能受限&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;h4 id="真实使用环境复杂多变">真实使用环境复杂多变&lt;/h4>
&lt;p>字节内部的使用场景非常多，我们不仅要支持各种业务线的开发，还要支持一些横向的基础组件。不同的业务，不同的场景，数据规模各异。
如何成为通用且高效的地解决 bufio.Reader 的问题成为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 面临的内部重要挑战。我们既然已经站在 Fasthttp 这个“巨人”的肩膀上了，能否往前再走一步呢？&lt;/p>
&lt;p>答案是肯定的。基于内部的使用场景，同时结合 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 的优势，我们设计出了 &lt;strong>自适应 linked buffer&lt;/strong> ，并且用它替代掉了原生的 bufio.Reader。
从下图可以看到，我们的 buffer 不再是一个固定长度的 buffer，而是一条链，这条链上的每一个 buffer 大小能够&lt;strong>根据线上真实请求进行动态扩缩容调整&lt;/strong> ，同时搭配 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 中&lt;strong>基于 LT 触发的模型做数据预拷贝&lt;/strong> 。
从实施效果上来看，这个自适应调整能够让我们的业务方完全无感地支撑任何他们的业务特性。也是因为我们能够将 buffer 进行动态扩缩容调整，从而能够保证在&lt;strong>协议层最大程度做到零拷贝协议解析&lt;/strong> ，这能够带来整体解析上的性能提升，时延也会更低。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/13.png" alt="image">&lt;/p>
&lt;h4 id="针对-http11-进行中的优化">针对 HTTP/1.1 进行中的优化&lt;/h4>
&lt;p>因为目前在字节内部 HTTP/1.1 还是一个比较主流的协议，所以我们基于 HTTP/1.1 做了很多尝试。&lt;/p>
&lt;p>首先是&lt;strong>协议层探索&lt;/strong> 。我们正在尝试基于 &lt;strong>Header Passer 的重构&lt;/strong> ，把解析 Header 的流程做得更高效。我们还尝试了做一些&lt;strong>传输层预解析&lt;/strong> ，将一些比较固化的逻辑下沉到传输层做加速。&lt;/p>
&lt;p>其次是&lt;strong>传输层探索&lt;/strong> 。这包括&lt;strong>使用 writev 整合发送 Header &amp;amp; Body&lt;/strong> 达到减少系统调用次数的目的，以及通过&lt;strong>新增接口整合 &lt;code>.Peek() + .Skip()&lt;/code>&lt;/strong> 语义，在内部提供一个更高效的实现。&lt;/p>
&lt;h4 id="hertz-benchmark">Hertz Benchmark&lt;/h4>
&lt;p>下图是 Benchmark 的开源数据。左侧第一张图是在同等的机器环境上，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和横向的框架 Gin、Fasthttp 极限 QPS 比较情况，蓝线是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 处于较高极限 QPS 的状态。
第二张图是 TP99 时延状态，第三张图是 TP999 时延状态，可以看到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的整体时延是处于一个更低的水平上。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/14.png" alt="image">&lt;/p>
&lt;h4 id="字节跳动服务网格控制面从-gin-迁移至-hertz">字节跳动服务网格控制面从 Gin 迁移至 Hertz&lt;/h4>
&lt;p>CloudWeGo 公众号曾发布关于字节跳动服务网格控制面的文章，讲述字节跳动服务网格从 Gin 框架迁移到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的落地实践。下图是他们代码展示的真实收益，从 Gin 框架替换成为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架后，
&lt;strong>CPU 流量从大概快到 4K 降到大约只有 2.5K，Goroutine 数量从 6w 降到不足 100 个&lt;/strong> ，Goroutine 稳定性得到极大地提升。
同时替换成 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后，&lt;strong>框架相关的开销已经基本消失，服务网格在线上稳定承载了超过 13M QPS 的流量&lt;/strong> 。&lt;/p>
&lt;p>字节跳动服务网格基于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的实践：https://mp.weixin.qq.com/s/koi9q_57Vk59YYtO9cyAFA&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/15.png" alt="image">&lt;/p>
&lt;h3 id="小结-2">小结&lt;/h3>
&lt;p>第三章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分层抽象&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>解构 HTTP 框架，分层解耦。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易用可扩展&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>提供了更丰富 API 和足够灵活的拓展能力，在每一层抽象中都提供了一个足够灵活的扩展能力应对可能的需求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自主可控的高性能探索&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>自适应 buffer，零拷贝解析，未来将会进行更多的高性能探索。&lt;/p>
&lt;h2 id="未来规划和挑战">未来规划和挑战&lt;/h2>
&lt;p>我认为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 未来的发展规划主要围绕以下几个方面：首先，&lt;strong>打造泛 HTTP 框架&lt;/strong> 。我们的最终目标是希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够解决在 HTTP 领域内的所有问题；其次，&lt;strong>助力 CloudWeGo&lt;/strong> ，希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够助力 CloudWeGo 打造一个企业级云原生微服务矩阵；最后希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够&lt;strong>持续服务更多的用户&lt;/strong> 。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>本次分享的主要内容总结如下：&lt;/p>
&lt;ul>
&lt;li>字节跳动内部 Go HTTP 框架的变迁：从基于开源封装，到开启自研之路；&lt;/li>
&lt;li>企业级 HTTP 框架的设计考量和落地思路：破圈、需求提炼、框架科学发展观；&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 核心特点：分层抽象、易用可扩展、自主可控的性能探索；&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 未来的规划和挑战：框架持续打磨、助力 CloudWeGo、服务更多用户。&lt;/li>
&lt;/ul>
&lt;p>最后欢迎对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 感兴趣的同学积极参与到 CloudWeGo 社区中，我们一起完善 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，共同建设 CloudWeGo！&lt;/p></description></item><item><title>Blog: Hertz v0.3.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/09/20/hertz-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/20/hertz-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/198">#198&lt;/a>] feat: 添加获取 Hertz client dialer 名称的方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/251">#251&lt;/a>] feat: Hertz server 启动日志添加网络库的名称。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/238">#238&lt;/a>] refactor: 重构 Hertz client 初始化 HostClient 和 TLSHostClient 的逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/226">#226&lt;/a>] optimize: 使用 &amp;ldquo;warning&amp;rdquo; 日志提示非法的 http 状态码。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/249">#249&lt;/a>] fix: 修复 Hertz server 优雅退出时无法执行完全部 hook 函数的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/232">#232&lt;/a>] fix: 修复路由尾斜线重定向在边缘情况失效的问题。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/217">#217&lt;/a>] chore: 更新提交 PR 时的填写模板。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.3.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/08/29/hertz-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/08/29/hertz-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/182">#182&lt;/a>] feat: 添加服务注册 &amp;amp; 服务发现 &amp;amp; 负载均衡。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/6">[#6]&lt;/a> feat: 添加 zookeeper 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/7">[#7]&lt;/a> feat: 添加 nacos 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/8">[#8]&lt;/a> feat: 添加 Consul 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/9">[#9]&lt;/a> feat: 添加 polaris 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/14">[#14]&lt;/a> feat: 添加 etcd 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/15">[#15]&lt;/a> feat: 添加 servicecomb 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/16">[#16]&lt;/a> feat: 添加 eureka 服务注册与发现的扩展。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/175">#175&lt;/a>] refactor: 区别全局默认 dialer 和 client 局部 dialer（指定了 dialer 的 client 不再受全局 dialer 改变而改变）修改全局 dialer 影响面较大，标记 deprecated，后续统一到 client 初始化时传参指定 dialer 方式修改局部 dialer，以及移除了功能完全被 dialer 覆盖的 dialFunc 扩展。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/205">#205&lt;/a>] optimize: 更改默认返回值。&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/174">#174&lt;/a>] test: 修正 TestRouterMiddlewareAndStatic 单测。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/190">#190&lt;/a>] fix: 修改同名的路由组。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/192">#192&lt;/a>] fix: 修复 handler 中的引用相同包名的问题，并把获取 unique 变量名的方法单独提出来。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/208">#208&lt;/a>] fix: 当服务停止时修复取消注册失败。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/202">#202&lt;/a>] fix: 获取到了错误的 IPv6 本地回环地址。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/196">#196&lt;/a>] fix: 修复 typo。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/155">#155&lt;/a>] fix: 修复thrift的命名方式，struct name 与 thriftgo 的 namestyle 保持一致。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/169">#169&lt;/a>] fix: 修复 thrift 的 namespace 尾缀包含&amp;quot;.thrift&amp;quot;的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/184">#184&lt;/a>] fix: 修复使用标准网络库劫持连接时的超时错误。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/162">#162&lt;/a>] fix: 修复 IDL 中定义的路由最后一级为&amp;quot;/&amp;ldquo;时的报错。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/189">#189&lt;/a>] 回滚 &lt;a href="https://github.com/cloudwego/hertz/pull/162">cloudwego/hertz#162&lt;/a> 的修改。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/203">#203&lt;/a>] AddMissingPort 函数增加对裸 v6 地址的处理。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/186">#186&lt;/a>] 支持 codecov。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.2.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/07/22/hertz-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/07/22/hertz-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/124">#124&lt;/a>] feat: 增加参数控制是否使用 hijackConnPool。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/116">#116&lt;/a>] feat: update 也可使用模板更新 handler 及 middleware。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/130">#130&lt;/a>] feat: 如果 Cookie.Value 中存在非法字符，则打印告警日志。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/143">#143&lt;/a>] feat: 增加一个接口支持自定义信号捕捉逻辑，以便根据场景调节优雅退出需要应对的信号类型。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/114">#114&lt;/a>] feat: 标准网络库 Read 方法中调用 connection.Release()，防止在多次少量调用 Read 方法时不回收内存导致的 OOM。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/112">#112&lt;/a>] feat: 修正了 x-www-form-urlencoded 编码下无法读到 bodystream 类型数据。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/105">#105&lt;/a>] feat: client 为 ALPN 和 http2 抽象出协议层 HostClient。client 删除 readbuffersize 和 writebuffersize 配置项。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/92">#92&lt;/a>] feat: hz 命名行工具支持 windows。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/102">#102&lt;/a>] feat: Hertz client 关闭默认的重试逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/111">#111&lt;/a>] optimize: 调用 bytesconv.AppendHTTPDate 时，为切片预分配容量，以防止产生额外的拷贝。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/128">#128&lt;/a>] optimize: 去掉路由树中无用逻辑。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/108">#108&lt;/a>] optimize: 通过提前调用 regexp.MustCompile，避免程序重复解析正则表达式。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/125">#125&lt;/a>] chore: 更新 license check 方式。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/104">#104&lt;/a>] fix: cacheLock 可能会因潜在发生的 panic 导致解锁失败。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/96">#96&lt;/a>] fix: ci 可能被调度到 arm 机器上导致报错 exec format error。&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/103">#103&lt;/a>] style: 修正不符合语义的错误拼写 “Ungzipped”。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/90">#90&lt;/a>] style: 常量替换和去掉了重复的类型转换。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/94">#94&lt;/a>] refactor: 使用 appendCookiePart 函数简化代码。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/97">#97&lt;/a>] docs: 文档标点符号优化。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 超大规模的企业级微服务 HTTP 框架 — Hertz 正式开源！</title><link>https://www.cloudwego.io/zh/blog/2022/06/21/%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1-http-%E6%A1%86%E6%9E%B6-hertz-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/21/%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1-http-%E6%A1%86%E6%9E%B6-hertz-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</guid><description>
&lt;p>今天，经过了字节跳动内部一年多的使用和迭代，高性能企业级 HTTP 框架—— &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，已在 CloudWeGo 正式开源啦！&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 &lt;strong>1 万&lt;/strong>，
峰值 QPS 超过 &lt;strong>4 千万&lt;/strong>，具有 &lt;strong>高易用性&lt;/strong> 、 &lt;strong>易扩展&lt;/strong> 、&lt;strong>低时延&lt;/strong>的特点。对于字节跳动服务框架团队和 CloudWeGo 而言，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 将不仅仅是一个开源项目，它也是一个真实的超大规模企业级实践。&lt;/p>
&lt;p>&lt;strong>项目地址：https://github.com/cloudwego/hertz&lt;/strong>&lt;/p>
&lt;p>未来，字节跳动基础架构团队将以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开源库为主进行迭代，坚持内外维护一套代码，统一进行迭代演进，为用户提供更好的体验。&lt;/p>
&lt;h2 id="01-hertz-概述">01 Hertz 概述&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是一个超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。
随着内部业务的不断发展，对高性能、多场景的需求日渐强烈。而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。
因此，为了满足业务需求，更好的服务各大业务线，2020 年初，字节跳动服务框架团队经过内部对使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，
开始基于自研网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 开发内部框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。
2021 年 7 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式上线 1.0 版本。&lt;/p>
&lt;p>在经历了字节跳动内部一年多的使用后，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架成为了字节跳动内部最大的 HTTP 框架，&lt;strong>线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万&lt;/strong>。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 除了业务线的同学使用外，也服务于内部很多基础组件，如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。
在如此大规模的场景下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 拥有极强的稳定性和性能，bug 和 kernel case 也几乎暴露无遗并进行修复。同时 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 坚持的内外维护一套代码，也为开源出去的 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架提供了强有力的保障。&lt;/p>
&lt;p>下面是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的一些特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>稳定性&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在如此大规模的场景下，每一个 PR 的合入、每一次发版都要慎之又慎，稍有不慎便可能造成千万甚至更多的损失。我们制定了规范的 PR、发版流程，每次合入代码需要由有经验的同学审核。
即便如此，为了降低风险，我们也搭建了各种测试场景，包括兼容性、高并发、大小包等场景，每次的 PR、发版都需要测试一段时间，充分测试，将每次发版的风险减少到最低。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高易用性&lt;/strong>&lt;/p>
&lt;p>在开发过程中，快速写出正确的代码往往是重要的。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在设计 API 时，考虑到用户的使用习惯，参考业界主流框架使用 API 的方式，并加以优化。在 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在迭代过程中，积极听取用户意见，持续打磨框架，
比如很多用户希望 Client 也有 Trace 的能力，为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> Client 支持了中间件能力；在代理场景中，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> Client 也支持了流式处理。
在做中间件和流式处理设计时，也考虑到用户实际使用习惯，帮助用户更快地写出正确的代码。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也提供了命令行工具，一键生成代码，提高框架的易用性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>易扩展&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 采用了分层设计，提供了较多的接口以及默认的扩展实现，用户也可以自行扩展，详情可参考 CloudWeGo 官网的 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 扩展部分。
同时得益于框架的分层设计，框架的扩展性也会大很多。目前仅将稳定的能力开源给社区，更多的规划参考 RoadMap。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低延时&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 默认使用自研的高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在一些特殊场景中，相较于 go net，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在 QPS、时延上均具有一定优势。关于性能数据，可参考下图 Echo 数据。
在内部实践中，某些典型服务，如框架占比较高的服务、网关等服务，迁移 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后相比 Gin 框架，资源使用显著减少，&lt;strong>CPU 使用率随流量大小降低 30%—60%。&lt;/strong>
关于详细的性能数据，可参考：https://github.com/cloudwego/hertz-benchmark。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz_Open_Source/Echo.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>命令行工具&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了一个简单易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，开箱即用使用 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>；Hz 也提供更新能力，用户的 IDL 如果发生改变，Hz 可以更新脚手架。
目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。
同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果觉得默认模板不能够满足的需求，可以自定义生成的模板。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>自 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 发布以来，内部反响优异。在内部，除最常见的前后端通信场景外，还涉及网关、上传、下载、代理等场景；所用到的交互模式除 ping-pong 外，还有 streaming、chunk 等；
使用的协议除 HTTP1 外，还有 HTTP2、Websocket 等。这些复杂的交互场景和交互模式都对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 Server 和 Client 的可用性和稳定性提出了不小的挑战。
为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 快速响应用户需求；搭建稳定性测试服务尽可能模拟线上真实复杂场景；较高的单测覆盖率保证代码逻辑正常。&lt;/p>
&lt;h2 id="02-内外版本维护">02 内外版本维护&lt;/h2>
&lt;p>字节跳动内部有着完善的微服务体系，团队非常重视开源建设和承诺，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和 CloudWeGo 中的开源项目 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相同，&lt;strong>保持内外一致&lt;/strong>，项目的核心能力均迁移至开源库中，
在内部仅封装一层壳帮助企业内无感升级，以保证对开源长期维护的承诺，并且&lt;strong>所有开源特性，都会在内部的稳定性验证后才会开源出来&lt;/strong>。&lt;/p>
&lt;p>后续，团队将持续以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开源库为主进行迭代，及时响应社区需求与问题，为用户提供更好的体验和使用保障。&lt;/p>
&lt;p>对于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的开发者来说，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 同样支持对框架进行灵活的扩展，以适应业务需求。我们也欢迎外部的开发者将自己的贡献提交到社区当中，在社区进行开源共建，共同打造一款有着完善生态、极致性能和高易用性的 HTTP 框架。&lt;/p>
&lt;h2 id="03-roadmap">03 RoadMap&lt;/h2>
&lt;p>对于基础架构团队而言，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 不仅仅是一个开源项目，它也是一个&lt;strong>真实的超大规模企业级实践项目&lt;/strong>。通过开源，我们希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能丰富云原生社区的 Golang 中间件体系，
完善 CloudWeGo 生态矩阵，为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。&lt;/p>
&lt;p>如前文所述，目前 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 只开源了内部经过稳定性验证的部分，未来，我们会进一步推动其走向完善：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>云原生能力支持&lt;/strong>。支持 xDS API，从 Istio 动态获取服务配置。&lt;/li>
&lt;li>&lt;strong>多协议的支持&lt;/strong>。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 目前只开源了 HTTP1 的部分，未来我们还会开源其他协议，如：HTTP2、Websocket、ALPN 等，为开发者提供更多场景的微服务需求支持。如果有需求也可以提交 issue 告诉我们，让我们知道您的需求以便快速支持。&lt;/li>
&lt;li>&lt;strong>更好用的命令行工具&lt;/strong>。我们将继续迭代 Hz，持续集成各种常用的中间件，提供模块化构建能力，用户可以按需选择所需组件。&lt;/li>
&lt;li>&lt;strong>更完善的生态支持&lt;/strong>。由于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 没有采用 go net 的数据结构，需要更多的生态支持。第一批开源我们只开源了 CORS、Trace、Metrics 等生态。未来我们还将支持包括反向代理、Session 等生态。&lt;/li>
&lt;li>&lt;strong>结合内外部用户需求，持续迭代&lt;/strong>。项目开源后，我们也会根据开发者需求开展迭代。&lt;/li>
&lt;/ul>
&lt;p>欢迎大家向 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提交 issue 和 PR 一起来共建。&lt;/p>
&lt;p>我们诚心期待更多的开发者加入，也期待 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 助力越来越多的企业快速构建云原生架构。我们也真诚欢迎企业用户迁移使用，我们会提供专项技术支持和交流，欢迎入群咨询。&lt;/p>
&lt;h2 id="04-相关链接">04 相关链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>项目地址: &lt;a href="https://github.com/cloudwego/hertz">https://github.com/cloudwego/hertz&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>周边生态: &lt;a href="https://github.com/hertz-contrib">https://github.com/hertz-contrib&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Blog: 字节跳动开源 Go HTTP 框架 Hertz 设计实践</title><link>https://www.cloudwego.io/zh/blog/2022/06/21/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90-go-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/21/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90-go-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="01-前言">01 前言&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。在经过了字节跳动内部一年多的使用和迭代后，如今已在 CloudWeGo 正式开源。
目前，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万。除了各个业务线的同学使用外，也服务于内部很多基础组件，
如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。在如此大规模的场景下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 拥有极强的稳定性和性能，在内部实践中某些典型服务，
如框架占比较高的服务、网关等服务，迁移 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后相比 Gin 框架，资源使用显著减少，CPU 使用率随流量大小降低 30%—60%，时延也有明显降低。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 坚持 &lt;strong>内外维护一套代码&lt;/strong> ，为开源使用提供了强有力的保障。通过开源， &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也将丰富云原生的 Golang 中间件体系，完善 CloudWeGo 生态矩阵，
为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。&lt;/p>
&lt;p>本文将重点关注 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的&lt;strong>架构设计&lt;/strong>与 &lt;strong>功能特性&lt;/strong> 。&lt;/p>
&lt;h2 id="02-项目缘起">02 项目缘起&lt;/h2>
&lt;p>最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。随着内部业务的不断发展，高性能、多场景的需求日渐强烈。
而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。因此，为了满足业务需求，更好的服务各大业务线，
2020 年初，字节跳动服务框架团队经过内部使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，开始基于自研网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 开发内部框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，
让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。&lt;/p>
&lt;h2 id="03-架构设计">03 架构设计&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 设计之初调研了大量业界优秀的 HTTP 框架，同时参考了近年来内部实践中积累的经验。为了保证框架整体上满足：1. 极致性能优化的可能性；2. 面对未来不可控需求的扩展能力，
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 采用了 4 层分层设计，保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体架构图如图 1 所示。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hertz_Architectural.png" alt="image">&lt;/p>
&lt;p align="center">
图1 Hertz 架构图
&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 从上到下分为：应用层、路由层、协议层和传输层，每一层各司其职，同时公共能力被统一抽象到公共层（Common），做到跨层级复用。
另外，同主库一同发布的还有作为子模块的 Hz 脚手架，它能够协助使用者快速搭建出项目核心骨架以及提供实用的构建工具链。&lt;/p>
&lt;h3 id="应用层">应用层&lt;/h3>
&lt;p>应用层是和用户直接交互的一层，提供丰富易用的 API，主要包括 Server、Client 和一些其他通用抽象。Server 提供了注册 HandlerFunc、Binding、Rendering 等能力；Client 提供了调用下游和服务发现等能力；
以及抽象一个 HTTP 请求所必须涉及到的请求（Request）、响应（Response）、上下文（RequestContext）、中间件（Middleware）等等。 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 Server 和 Client 都能够提供中间件这样的扩展能力。&lt;/p>
&lt;p>应用层中一个非常重要的抽象就是对 Server HandlerFunc 的抽象。早期，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 路由的处理函数 （HandlerFunc）中并没有接收标准的 context.Context，我们在大量的实践过程中发现，
业务方通常需要一个标准的上下文在 RPC Client 或者日志、Tracing 等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次 HTTP 请求之内，而以上提到的场景往往存在异步的传递和处理，
导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。为此我们做了诸多尝试，但是因为核心原因在于请求上下文（RequestContext）的生命周期无法优雅的按需延长，
最终在各种设计权衡下，我们在路由的处理函数签名中增加一个标准的上下文入参，通过分离出生命周期长短各异的两个上下文的方式，从根本上解决各种因为上下文生命周期不一致导致的异常问题，即：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/RequestContext.png" alt="image">&lt;/p>
&lt;h3 id="路由层">路由层&lt;/h3>
&lt;p>路由层负责根据 URI 匹配对应的处理函数。&lt;/p>
&lt;p>起初，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的路由基于 &lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 开发，但随着使用的用户越来越多，&lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 渐渐不能够满足需求，主要体现在 &lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 不能够同时注册静态路由和参数路由，
即 &lt;code>/a/b&lt;/code>， &lt;code>/:c/d&lt;/code> 这两个路由不能够同时注册；甚至有一些更特殊的需求，如 &lt;code>/a/b&lt;/code>、&lt;code>/:c/b&lt;/code> ，当匹配 &lt;code>/a/b&lt;/code> 路由时，两个路由都能够匹配上。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 为满足这些需求重新构造了路由树，用户在注册路由时拥有很高的自由度：支持静态路由、参数路由的注册；支持按优先级匹配，如上述例子会优先匹配静态路由 &lt;code>/a/b&lt;/code>；支持路由回溯，
如注册 &lt;code>/a/b&lt;/code>、&lt;code>/:c/d&lt;/code>，当匹配 &lt;code>/a/d&lt;/code> 时仍然能够匹配上；支持尾斜线重定向，如注册 &lt;code>/a/b&lt;/code>，当匹配 &lt;code>/a/b/&lt;/code> 时能够重定向到 &lt;code>/a/b&lt;/code> 上。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了丰富的路由能力来满足用户的需求，更多的功能可以参考 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/reference/config/">Hertz 配置文档&lt;/a>。&lt;/p>
&lt;h3 id="协议层">协议层&lt;/h3>
&lt;p>协议层负责不同协议的实现和扩展。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持&lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/framework-exten/protocol/">协议的扩展&lt;/a>，用户只需要实现下面的接口便可以按照自己的需求在引擎（Engine）上扩展协议，
同时也支持通过 ALPN 协议协商的方式注册。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 首批只开源了 HTTP1 实现，未来会陆续开源 HTTP2、QUIC 等实现。
协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Server.png" alt="image">&lt;/p>
&lt;h3 id="传输层">传输层&lt;/h3>
&lt;p>传输层负责底层的网络库的抽象和实现。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持底层网络库的扩展。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 原生完美适配 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在时延方面有很多深度的优化，非常适合时延敏感的业务接入。&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 对 TLS 能力的支持有待完善，而 TLS 能力又是 HTTP 框架必备能力，
为此 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 底层同时支持基于 Golang 标准网络库的实现适配，同时支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。&lt;/p>
&lt;p>&lt;strong>网络库的扩展&lt;/strong>：
&lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/framework-exten/network-lib/">网络库扩展&lt;/a>&lt;/p>
&lt;h3 id="hz-脚手架">Hz 脚手架&lt;/h3>
&lt;p>与 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 一并开源的还有一个易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 达到开箱即用的状态；
Hz 也支持基于 IDL 的更新能力，能够基于 IDL 变动智能地更新项目代码。目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。
同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果默认模板不能够满足需求，完全能够按需定义。&lt;/p>
&lt;p>未来，我们将继续迭代 Hz，持续集成各种常用的中间件，提供更高层面的模块化构建能力。给 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的用户提供按需调整的能力，通过灵活的自定义配置打造一套满足自身开发需求的脚手架。&lt;/p>
&lt;h3 id="common-组件">Common 组件&lt;/h3>
&lt;p>Common 组件主要存放一些公共的能力，比如错误处理、单元测试能力、可观测性相关能力（Log、Trace、Metrics 等）。对于服务可观测性的能力，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了默认的实现，用户可以按需装配；
如果用户有特殊的需求，也可以通过 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供的接口注入。比如对于 Trace 能力，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了默认的实现，也提供了将 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 串起来的 Example。如果想注入自己的实现，也可以实现下面的接口：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Common.png" alt="image">&lt;/p>
&lt;p>&lt;strong>Example&lt;/strong>：
&lt;a href="https://github.com/cloudwego/hertz-examples/blob/main/tracer/README.md">https://github.com/cloudwego/hertz-examples/blob/main/tracer/README.md&lt;/a>&lt;/p>
&lt;h2 id="04-功能特性">04 功能特性&lt;/h2>
&lt;h3 id="中间件">中间件&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 除了提供 Server 的中间件能力，还提供了 Client 中间件能力。用户可以使用中间件能力将通用逻辑（如：日志记录、性能统计、异常处理、鉴权逻辑等等）和业务逻辑区分开，让用户更加专注于业务代码。
Server 和 Client 中间件使用方式相同，使用 Use 方法注册中间件，中间件执行顺序和注册顺序相同，同时支持预处理和后处理逻辑。&lt;/p>
&lt;p>Server 和 Client 的中间件实现方式并不相同。对于 Server 来说，我们希望减少栈的深度，同时也希望中间件能够默认的执行下一个，用户需要手动终止中间件的执行。
因此，我们将 Server 的中间件分成了两种类型，即不在同一个函数调用栈（该中间件调用完后返回，由上一个中间件调用下一个中间件，如图 2 中 B 和 C）和在同一个函数调用栈的中间件（该中间件调用完后由该中间件继续调用下一个中间件，如图 2 中 C 和 Business Handler）。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Middleware.png" alt="image">&lt;/p>
&lt;p align="center">
图2 中间件链路
&lt;/p>
&lt;p>其核心是需要一个地方存下当前的调用位置 index，并始终保持其递增。恰好 RequestContext 就是一个存储 index 合适的位置。
但是对于 Client，由于没有合适的地方存储 index，我们只能退而求其次，抛弃 index 的实现，将所有的中间件构造在同一调用链上，需要用户手动调用下一个中间件。&lt;/p>
&lt;h3 id="流式处理">流式处理&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供 Server 和 Client 的流式处理能力。HTTP 的文件场景是十分常见的场景，除了 Server 侧的上传场景之外，Client 的下载场景也十分常见。
为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持了 Server 和 Client 的流式处理。在内部网关场景中，从 Gin 迁移到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后，CPU 使用量随流量大小不同可节省 30%—60% 不等，服务压力越大，收益越大。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开启流式功能的方式也很容易，只需要在 Server 上或 Client 上添加一个配置即可，可参考 CloudWeGo 官网 Hertz 文档的 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/engine/#%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86">Server 流式处理&lt;/a> 部分和 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/client/#%E6%B5%81%E5%BC%8F%E8%AF%BB%E5%93%8D%E5%BA%94%E5%86%85%E5%AE%B9">Client 流式处理&lt;/a> 部分。&lt;/p>
&lt;p>由于 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 采用 LT 的触发模式，由网络库主动将将数据从 TCP 缓冲区读到用户态，并存储到 buffer 中，否则 epoll 事件会持续触发。
因此 Server 在超大请求的场景下，由于 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 持续将数据读到用户态内存中，可能会有 OOM 的风险。HTTP 文件上传场景就是一个典型的场景，但 HTTP 上传服务又是很常见的场景，
因此我们支持标准网络库 go net，并针对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 做了特殊优化，暴露出 Read() 接口，防止 OOM 发生。&lt;/p>
&lt;p>对于 Client，情况并不相同。流式场景下会将连接封装成 Reader 暴露给用户，而 Client 有连接池管理，那这样连接就多了一种状态，何时关连接，何时复用连接成了一个问题。
由于框架侧并不知道该连接何时会用完，框架侧复用该连接不现实，会导致串包问题。由于 GC 会关闭连接，因此我们起初设想流式场景下的连接交由用户后，由 GC 负责关闭，这样也不会导致资源泄漏。
但是在测试后发现，由于 GC 存在一定时间间隔，另外 TCP 中主动关闭连接的一方需要等待 2RTT，在高并发场景下会导致 fd 被打满的情况。
最终我们提供了复用连接的接口，对于性能有场要求用户，在使用完连接后可以将连接重新放入连接池中复用。&lt;/p>
&lt;h2 id="05-性能表现">05 性能表现&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 使用字节跳动自研高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在提高网络库效率方面有诸多实践，参考已发布文章 &lt;strong>字节跳动在 Go 网络库上的实践&lt;/strong> 。
除此之外，&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 还针对 HTTP 场景进行优化，通过减少拷贝和系统调用次数提高吞吐以及降低时延。为了衡量 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 性能指标，我们选取了社区中有代表性的框架 Gin（net/http）和 Fasthttp 作为对比，如图 3 所示。
可以看到，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的极限吞吐、TP99 等指标均处于业界领先水平。未来，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 还将继续和 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 深度配合，探索 HTTP 框架性能的极限。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Fasthttp.png" alt="image">&lt;/p>
&lt;p align="center">
图3 Hertz 和其他框架性能对比
&lt;/p>
&lt;h2 id="06-一个-demo">06 一个 Demo&lt;/h2>
&lt;p>下面简单演示一下 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是如何开发一个服务的。&lt;/p>
&lt;ol>
&lt;li>首先，定义 IDL，这里使用 Thrift 作为 IDL 的定义（也支持使用 Protobuf 定义的 IDL），编写一个名为 Demo 的 service。这个服务有一个 API: Hello，它的请求参数是一个 query，响应是一个包含一个 RespBody 字段的 Json。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hello.png" alt="image">&lt;/p>
&lt;ol start="2">
&lt;li>接下来我们使用 Hz 生成代码，并整理和拉取依赖。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hz.png" alt="image">&lt;/p>
&lt;ol start="3">
&lt;li>填充业务逻辑，比如我们返回 &lt;code>hello，${Name}&lt;/code>，那我们在 &lt;code>biz/handler/example/hello_service.go&lt;/code> 中添加以下代码即可。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hello_service.png" alt="image">&lt;/p>
&lt;ol start="4">
&lt;li>编译并运行项目。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Build.png" alt="image">&lt;/p>
&lt;p>到现在一个简单的 Hertz 项目已经生成，下面我们来测试一下。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hertz-Examples.png" alt="image">&lt;/p>
&lt;p>以上 Demo 可以在 &lt;a href="https://github.com/cloudwego/hertz-examples">Hertz-Examples&lt;/a> 中查看，之后就可以愉快地构建自己的项目了。&lt;/p>
&lt;h2 id="07-后记">07 后记&lt;/h2>
&lt;p>希望以上的分享能够让大家对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 有一个整体上的认识。同时，我们也在不断地迭代 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>、完善 CloudWeGo 整体生态。欢迎各位感兴趣的同学们加入我们，共同建设 CloudWeGo。&lt;/p>
&lt;h2 id="08-参考资料">08 参考资料&lt;/h2>
&lt;p>&lt;a href="https://www.cloudwego.io/zh/docs/hertz/">&lt;strong>Hertz Doc&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cloudwego.io/zh/blog/2020/05/24/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/">&lt;strong>字节跳动在 Go 网络库上的实践&lt;/strong> &lt;/a>&lt;/p></description></item><item><title>Blog: Hertz v0.1.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/06/20/hertz-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/20/hertz-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/70">#70&lt;/a>] feat: 增加 hz 脚手架。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/64">#64&lt;/a>] feat: 增加 Hertz Request &amp;amp; Response 到 net/http Request &amp;amp; ResponseWriter 的适配器。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/45">#45&lt;/a>] feat: 添加 ctx.Body() 方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/44">#44&lt;/a>] feat: 在 request header 上添加 VisitAllCustomHeader 方法，使得传入的函数 f 只作用在用户自定义的 header 上（除了 cookie, host, content-length, content-type, user-agent 和 connection 以外的 header）。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/59">#59&lt;/a>] feat: 支持 windows 开发环境。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/37">#37&lt;/a>] refactor: 统一设置 request options 的入口，防止 options 未初始化导致 panic。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/52">#52&lt;/a>] refactor: 去掉 for 循环中多余的判空。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/33">#33&lt;/a>] refactor:
当子串长度确定为 1 时，可以直接调用 strings.IndexByte 函数而不是像 strings.Index 一样先调用 len() 判断子串长度后再调用 strings.IndexByte 函数；
为省去整型数字转字符串的工作，可以将相关变量直接定义成 string 类型而不是 int 类型；
net 包下的 JoinHostPort 函数会再次判断 &amp;lsquo;:&amp;rsquo; 是否在 addr 中，如果不在则将 host 与 port 相关字符串连接起来。然而在 AddingMissingPort 函数中调用 net.JoinHostPort 时，&amp;rsquo;:&amp;rsquo; 应不在 addr 中。所以在此可以不调用 net.JoinHostPort，而是直接连接 host 和 port 信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/27">#27&lt;/a>] refactor: 当字符串不需要格式化时，使用 hertz 的 errors.NewPublic 创建 error 而不是使用 fmt.Errorf。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/29">#29&lt;/a>] style(*): 修正拼写错误。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/57">#57&lt;/a>] optimize: 使用 http.TimeFormat 格式化 HTTP 中的 Date 信息，避免产生更多的复制。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/58">#58&lt;/a>] optimize: 服务端错误日志中添加对端地址。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/41">#41&lt;/a>] optimize(recovery): 使用 &amp;lsquo;CtxErrorf&amp;rsquo; 代替 &amp;lsquo;Errorf&amp;rsquo; 当服务 panic。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/60">#60&lt;/a>] docs: readme 文件中添加 icon。&lt;/li>
&lt;/ul></description></item></channel></rss>