---
title: "Combine Service"
date: 2022-06-02
weight: 2
description: >
---

> **This feature only works when using Thrift**

## Usage Scenarios

There could be decades method defined in service, but only one or two methods is needed by client.
Combine Service provides a way to split one service into several services.
For Example, there is a `ExampleService`

```thrift
service ExampleService {
    ExampleResponse Method0(3: ExampleRequest req)
    ExampleResponse Method1(3: ExampleRequest req)
    ExampleResponse Method2(3: ExampleRequest req)
}
```

We can split it into three services:

```thrift
service ExampleService0 {
    ExampleResponse Method0(3: ExampleRequest req)
}

service ExampleService1 {
    ExampleResponse Method1(3: ExampleRequest req)
}

service ExampleService2 {
    ExampleResponse Method2(3: ExampleRequest req)
}
```

Client can use one of them to generate code.

## Practice

root thrift:

```thrift
service ExampleService0 {
    ExampleResponse Method0(3: ExampleRequest req)
}

service ExampleService1 {
    ExampleResponse Method1(3: ExampleRequest req)
}

service ExampleService2 {
    ExampleResponse Method2(3: ExampleRequest req)
}
```

with `--combine-service` parameter, it will generate a new service named CombineService and also client/server code.
It's definition:

```thrift
service CombineService {
    ExampleResponse Method0(3: ExampleRequest req)
    ExampleResponse Method1(3: ExampleRequest req)
    ExampleResponse Method2(3: ExampleRequest req)
}
```

When used with `-service` at the same time, it will use CombineService to generate main package.
Attention: CombineService just combine methods defined in services, it won't generate code when method method name conflicts.

Tips:
You can use extends to combine services defined in several thrift files.
like:

```Thrift
service ExampleService0 extends thriftA.Service0 {
}

service ExampleService1 extends thriftB.Service1 {
}

service ExampleService2 extends thriftC.Service2 {
}
```

## Example

This feature only supports Thrift.

For Example, now there are 3 Services need to be combined, and the Thrift IDL file `demo.thrift` is as follow:

```Thrift
namespace go api

struct ExampleRequest {
	1: string message
}

struct ExampleResponse {
	1: string message
}

service ExampleService0 {
    ExampleResponse Method0(1: ExampleRequest req)
}

service ExampleService1 {
    ExampleResponse Method1(1: ExampleRequest req)
}

service ExampleService2 {
    ExampleResponse Method2(1: ExampleRequest req)
}
```

Execute Kitex code generating command with `--combine-service` to combine these services:

```
kitex --combine-service -service demo.kitex.combine demo.thrift
```

The directory generated is like this:

```
├── kitex_gen
    └── api
        ├── combineservice
        │   ├── client.go
        │   ├── combineservice.go
        │   ├── invoker.go
        │   └── server.go
        ├── demo.go
        ├── exampleservice0
        │   ├── client.go
        │   ├── exampleservice0.go
        │   ├── invoker.go
        │   └── server.go
        ├── exampleservice1
        │   ├── client.go
        │   ├── exampleservice1.go
        │   ├── invoker.go
        │   └── server.go
        ├── exampleservice2
        │   ├── client.go
        │   ├── exampleservice2.go
        │   ├── invoker.go
        │   └── server.go
        ├── k-consts.go
        └── k-demo.go
```

`exampleservice0`, `exampleservice1` and `exampleservice2` are normally generated codes.

`combineservice` is the code of the combined service generated by `--combine-service`, in which each method is an aggregation of another service, which can be used uniformly through this service.

So when the server starts, you only need to run the Service of this merged service, and you can run all the methods together:

```go
func main() {
	svr := api.NewServer(new(combineservice.CombineService))

	err := svr.Run()
	if err != nil {
		log.Println(err.Error())
	}
}
```
